<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SystemVerilog 教程 on Documentation du thème Shadocs</title>
    <link>/design/systemverilog/</link>
    <description>Recent content in SystemVerilog 教程 on Documentation du thème Shadocs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>The MIT License (MIT) Copyright © 2023 Jordan GAZEAU</copyright><atom:link href="/design/systemverilog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SystemVerilog 数据类型</title>
      <link>/design/systemverilog/01.data-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/01.data-types/</guid>
      <description>SystemVerilog 数据类型# 在Verilog中，所有数据类型都是 4 值的，即可以表示 0、1、X 和 Z。但是，在 test benches 的中，不需要这些4态变量。例如，要计算数据包的数量，我们需要一个 2 值变量。因此，System Verilog 引入了一类新的 2 值变量，即 0 和 1。
数据类型备忘表# sr. no. data type 1. 4-state 2. 2-state 3. Arrays 4. Strings 5. Structures and Union 6. Enumerated 7. User defined Tabular column.1. data types 有符号和无符号数字
无符号数：无符号数的符号不使用任何标志，即无符号数只能存储正数。
无符号二进制数的范围从 0 到 ((2^n) - 1)，n 表示位数。
有符号数：通过有符号数中的符号标志来区分正值和负值。有符号位的零有两种可能表示形式（正 (0) 和负 (1)）。
有符号二进制数的范围从 -2^(n-1) 到 2^(n-1)-1，n表示位数。
有符号二进制数在计算机系统中，一般用补码来表示：
有符号二进制数的补码：
正数的补码：与原码相同。 例如，+9的补码是00001001。 负数的补码：符号位为1，其余位为该数绝对值的原码按位取反；然后整个数加1。 例如，-7的补码：因为是负数，则符号位为“1”,整个为10000111；其余7位为-7的绝对值+7的原码 0000111按位取反为1111000；再加1，所以-7的补码是11111001。 已知一个数的补码，求原码：</description>
    </item>
    
    <item>
      <title>SystemVerilog 数组</title>
      <link>/design/systemverilog/02.array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/02.array/</guid>
      <description>Arrays# An array is a collection of elements, all of the same type, and accessed using its name and one or more indices. Verilog 2001 required that the low and high array limits must be part of the array declaration. System Verilog has introduced the compact array declaration style, where just giving the array size along with the array name declaration is enough.
The below figure shows the different types of arrays used in System Verilog.</description>
    </item>
    
    <item>
      <title>SystemVerilog 结构体和联合体</title>
      <link>/design/systemverilog/03.structure-and-union/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/03.structure-and-union/</guid>
      <description>Structure# A structure contains different data types with different sizes which grouped under one single structure name. Structure is originally unpacked form by default, but we can use &amp;lsquo;packed&amp;rsquo; keyword for converting into packed structure. Structure is different from normal array because array uses only same type of elements with sizes whereas structure uses different data types. The unpacked structure declared using &amp;lsquo;struct&amp;rsquo; keyword.
The below figure shows different types of structures in System Verilog.</description>
    </item>
    
    <item>
      <title>SystemVerilog 用户自定义</title>
      <link>/design/systemverilog/04.user-defined/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/04.user-defined/</guid>
      <description>Typedef# Typedef used to create new identifiers from longer datatype specification. It is similar to alias command. Typedef uses mainly in complex testbenches in System Verilog because it replaces the longer datatypes like int(unsigned longint, signed shortint), byte ,bit[7:0],logic[7:0] with identifiers in the code. Typedef uses in Class, Structure and Enumeration to make the datatype declarations easier.
Syntax:
typedef &amp;lt;base_type&amp;gt; &amp;lt;size&amp;gt; &amp;lt;type_name&amp;gt;;
Typedef in Class# The main use of Typedef in class is that sometimes we use class variable before the declaration of the class itself.</description>
    </item>
    
    <item>
      <title>SystemVerilog operators</title>
      <link>/design/systemverilog/05.operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/05.operators/</guid>
      <description>Operators :
the operator is a character that represents a specific mathematical or logical action or process.
Figure.1 operators s.No. Operator 1. Arithmetic Operator 2. Relational operator 3. Equality operator 4. Logical Operator 5. Bitwise Operator 6. Shift Operator 7. Conditional Operator 8. Reduction Operator 9. Concatenation and Replication Operators 1. Arithmetic Operators# We use arithmetic operators to perform basic mathematic functions on our variables. These operators should already be familiar as they are mostly replications of common mathematic symbols.</description>
    </item>
    
    <item>
      <title>SystemVerilog 控制流</title>
      <link>/design/systemverilog/06.control-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/06.control-flow/</guid>
      <description>Fig -1: Control Flow Control flow# Conditional Statements# Conditional statements are used to check whether the statements in the blocks are executed or not. Conditional statements create the block of statements. If the expression given is -
true - Execute the set of statements in the block.
false - the statements inside that block will not be executed.
else - if the expressions are false then the else block statements will execute at last.</description>
    </item>
    
    <item>
      <title>SystemVerilog 函数</title>
      <link>/design/systemverilog/07.functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/07.functions/</guid>
      <description>Functions# The main usage of a function is to write a piece of code that can be called at any time and n number of times by simply calling the function name which doesn&amp;rsquo;t take any simulation time to execute.
Functions are return type that will return only a single value mentioned in the function declaration, if not mentioned then return a one-bit value
Syntax :
initial begin function_name(arguments); end function &amp;lt;return_type(optional)&amp;gt; function_name(arguments);` statement1; statement2; .</description>
    </item>
    
    <item>
      <title>SystemVerilog 任务</title>
      <link>/design/systemverilog/08.tasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/08.tasks/</guid>
      <description>Tasks# Tasks are almost similar to Functions, but tasks can calculate multiple variables and return them using output or inout statements but are not necessary like function i.e., task is not a return type and tasks are capable of having time-consuming statements like #,@,wait. Task can call another task and functions also.
syntax:
task_name(arguments); task task_name(arguments); statement1; statement2; . . statementN; endtask limitations:
tasks are not synthesizable Flowchart:
Flowchart.1- task flowchart Example:</description>
    </item>
    
    <item>
      <title>SystemVerilog 循环</title>
      <link>/design/systemverilog/09.loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/09.loops/</guid>
      <description>Loops# A Loop is nothing but statements that need to be run more than once are included in the loop instead of writing the statements repeatedly. Loops will run multiple times based on conditional statements, If the condition is always true then it becomes an infinite loop and the system will hang.
Loops variations loops cheat sheet# S.No. Loops_variants Explanation 1. while Repeats the set of statements based on condition 2.</description>
    </item>
    
    <item>
      <title>Scheduler schematic</title>
      <link>/design/systemverilog/10.scheduler-schematics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/10.scheduler-schematics/</guid>
      <description>Scheduler schematic# The scheduling schematics are used to describe the element&amp;rsquo;s behavior and their interaction with each other. This interaction is described for event execution and its scheduling. It is important to note that Verilog and System Verilog is like a parallel programming language in terms of blocks or process executions.
Before going to the regions we have to know about simulation time and time slot.
The term simulation time is used to refer to the time value maintained by the simulator to model the actual time it would take for the system description being simulated.</description>
    </item>
    
    <item>
      <title>Processes</title>
      <link>/design/systemverilog/11.processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/11.processes/</guid>
      <description>Processes# A Processes or Thread is any piece of code that gets executed as a separate entity. A fork-join block creates the different threads that run in parallel.
In the below Fig-1 we can see that types of processes and the process controls.
Fig-1: The processes and process control blocks. Cheat sheet for processes:# S.no Processes Description 1. fork-join Parent threads will be executed only when all child threads are executed.</description>
    </item>
    
    <item>
      <title>Fine Grain Process Control</title>
      <link>/design/systemverilog/12.fine-grain-process-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/12.fine-grain-process-control/</guid>
      <description>Fine Grain Process Control# Systemverilog has a built in class named Process that allows one process(i.e, like fork_join) to access and control the processes/threads. When we fork off any thread, a new object of process class is created at that time. This object contains status information about that thread.
Fig-1: These are all the pre-defined methods which are available in fine grain process control. Cheat sheet of different fine-grain process control:# S.</description>
    </item>
    
    <item>
      <title>Interface</title>
      <link>/design/systemverilog/13.interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/13.interface/</guid>
      <description>In Verilog, the communication between blocks is specified using module ports.
Disadvantage of verilog module connections
Declaration must be duplicated in multiple modules. Risk of mismatched declaration. A change in design specifications can require modifications in multiple modules. Interface# SystemVerilog adds the interface construct which encapsulates the communication between blocks. An interface is a bundle of signals or nets through which a testbench communicates with a design.
sl. no. data type 1.</description>
    </item>
    
    <item>
      <title>Constraint</title>
      <link>/design/systemverilog/14.constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/14.constraint/</guid>
      <description>Constraint# The constraint is the way to assign legal value to the random variables. Constraints help us to limit the randomness of the variable by specifying the range. The way to create valid test configurations is by the use of constraints.
To enable the randomization we use rand() and randc() function. For using the constraint first, we need to assign the random variables by using the keyword rand or randc. After that declare the constraint statement.</description>
    </item>
    
    <item>
      <title>类和面向对象</title>
      <link>/design/systemverilog/15.classes-and-oops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/15.classes-and-oops/</guid>
      <description>Class# Class is user define data type. Classes contains a set of &amp;ldquo;properties&amp;rdquo; and &amp;ldquo;methods&amp;rdquo; in it. Both properties and methods are treated as Members of the class.
generally,
Class Properties are the variables inside a class and Class Methods are the Functions/Tasks inside a class.
Class declaration does not occupy any memory. we can define a class in systemverilog inside a module or outside of a module. Fig-1: All variations of a class.</description>
    </item>
    
    <item>
      <title>Coverage</title>
      <link>/design/systemverilog/17.functional-coverage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/17.functional-coverage/</guid>
      <description>Coverage# Coverage is a generic term for measuring progress to complete design verification. Coverage reports are read in percentage(%).
Need for coverage
To help us to understand whether all features of the design are measured and to know whether every line in the code is executed or not.
Types of coverage
Code Coverage Functional Coverage Code Coverage# Code coverage deals with the implementation part that is, it checks whether your tests exercised the “implementation” of the design specification, but it won’t check the verification plan.</description>
    </item>
    
    <item>
      <title>Assertion</title>
      <link>/design/systemverilog/18.assertion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/18.assertion/</guid>
      <description>Assertion# Assertions are primarily used to validate the behavior of a design. An assertion is a check embedded in design or bound to a design unit during the simulation. Warnings or errors are generated on the failure of a specific condition or sequence of events.
&amp;ldquo;The values of variables used in assertions are sampled in the Preponed region of a time slot, and the assertions are evaluated during the Observed region.</description>
    </item>
    
    <item>
      <title>Interprocess communication  </title>
      <link>/design/systemverilog/19.interprocess-communication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/19.interprocess-communication/</guid>
      <description>Interprocess communication# Interprocess communication (IPC) is a set of programming interfaces that allow a programmer to coordinate activities among different program processes that can run concurrently in an operating system. This allows a program to handle many user requests at the same time
Cheat Sheet# Components/Threads Description Events Different threads synchronize with each other via event handles in a testbench Semaphores Different threads might need to access the same resource; they take turns by using a semaphore Mailbox Threads/Components need to exchange data with each other; data is put in a mailbox and sent 1-Events# Event is used for synchronization between two or more concurrently active processes.</description>
    </item>
    
    <item>
      <title>Program Block</title>
      <link>/design/systemverilog/20.misc-constructs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/20.misc-constructs/</guid>
      <description>1.Program Block# The module is the basic building block in Verilog which works well for Design. However, for the testbench, a lot of effort is spent getting the environment properly initialized and synchronized, avoiding races between the design and the testbench, automating the generation of input stimuli, and reusing existing models and other infrastructure. System Verilog adds a new type of block called program block. It is declared using the program and endprogram keywords.</description>
    </item>
    
    <item>
      <title>Choosing-an-array</title>
      <link>/design/systemverilog/choosing-an-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/choosing-an-array/</guid>
      <description>Fixed Arrays/Static Arrays:# 1) Fixed Arrays Over All Arrays:
Fixed Arrays execute faster than all other types of arrays (i.e Associative arrays, dynamic arrays, queues) because it will store in uninitialized data segment (bss segment) of memory, so it will consume less simulation time to execute. And the heap is the segment where dynamic, associative and queue memory allocation takes place.
The below figure shows the memory layout. Figure.1. Memory Layout Size is known previously then we can choose fixed arrays over all other types of arrays.</description>
    </item>
    
    <item>
      <title>Control-Flow-Interview-questions</title>
      <link>/design/systemverilog/control-flow-interview-questions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/control-flow-interview-questions/</guid>
      <description>1. How to call the task inside a function? giving example with code.
Answer: Normally a function can be called inside the task. but calling the task inside the function is illegal because task has delay elements and the function does not have any delay elements but there is an exceptional case for it, by using the fork and join_none inside the function to call the task is possible.
Please refer to the below code for a better understanding.</description>
    </item>
    
    <item>
      <title>Data-type-Interview-questions</title>
      <link>/design/systemverilog/data-type-interview-questions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/data-type-interview-questions/</guid>
      <description>1.Is there any difference between reg and logic in SystemVerilog?
Answer:
Before system verilog ,verilog is mainly used for synthesis and verification purposes. In verilog there are two main data type
reg
2)net
Reg is mainly used when we want to store values in the variable .It is mainly used inside procedural block .mainly it is used for designing of sequential circuit .net variable are mainly continuously driven .In net type variable it is not possible to store value .</description>
    </item>
    
    <item>
      <title>Differences-between-macros-and-parameters</title>
      <link>/design/systemverilog/differences-between-macros-and-parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/differences-between-macros-and-parameters/</guid>
      <description>Macros Parameters macros are replaceable parameters are like variables macros works in pre-compilation state parameters works in Elaboration state syntax : `define macro_name value syntax : parameter parameter_name=value We can use `define in any file we can use parameter within the file we can&amp;rsquo;t give datatypes in macros we can use and change datatype in parameters Macros can have multiple lines multiple lines cannot be possible here because parameter is just like declaring variables We can give value for a macro in command line parameters value can&amp;rsquo;t be changed in command line Execution stage of macros and parameters# Parameters used in macros# parameter data = 5; // data will be replaced by value 5 in Elaboration `define DATA data // in pre-compilation `DATA will be replaced with data module tb(); int a,b; initial begin $display(&amp;#34;DATA=%0d&amp;#34;,`DATA); b= `DATA + 2; $display(&amp;#34; b=%0d&amp;#34;,b); end endmodule In the above code the parameter value of data =5 is used in the macro `DATA</description>
    </item>
    
    <item>
      <title>Interface-Interview-Questions</title>
      <link>/design/systemverilog/interface-interview-questions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/interface-interview-questions/</guid>
      <description>1. How does the clocking block handles synchronous reset?
Solution:
Synchronous reset is sampled only with respect to clock event. When reset is enabled, it will be effective only after next active clock edge.
clockingblock TB_CB @(posedge clk) default input #1step output #0; input rst; output a,b; input y; Note: The clocking block is only designed to handle synchronous reset - it should happen only be based on clock event. Reset in clocking block should be handled elsewhere.</description>
    </item>
    
    <item>
      <title>Processes-InterviewQuestions</title>
      <link>/design/systemverilog/processes-interviewquestions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/design/systemverilog/processes-interviewquestions/</guid>
      <description>1.Difference between fork_join,fork_join_any and fork_join_none ?
fork_join fork_join_any fok_join_none In fork_join the main(parent) threads will execute after all the threads(child threads) in the fork_join is executed In fork_join_any the main(parent) threads executes if any one of the child threads excecutes In fork_join_none child threads and main(parent) threads are executed parallely 2.Can we use wait_fork in fork_join ?
We know that in fork_join the main thread is executed only when all the threads in fork_join is executed so here no need of using wait_fork.</description>
    </item>
    
  </channel>
</rss>
