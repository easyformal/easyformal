---
title: "约束"

tags: "sv"

weight: 14
---

约束（constraint）是将合法值分配给随机变量的方法。通过指定范围，约束帮助我们限制变量的随机性。创建有效的测试配置的方法是使用约束。  

要启用随机化，我们使用 rand() 和 randc() 函数。 
要使用约束，首先需要使用关键字 rand 或 randc 分配随机变量。然后声明约束语句。  

所有约束块同时处于活动状态。   

**语法**    
```systemverilog
constraint  constraint_name{random_variable[range];}
```  

**注意**- 如果变量在没有任何约束的情况下随机化，则范围内的任何值都将以相等的概率分配给变量。  

|序号|约束|
|:-----|:----------|
|1.|Random Function System|
|2.|Random Variables|
|3.|std::randomize|
|4.|Constraint Block|
|5.|Array Randomization|
|6.|Inside Constraint|
|7.|Inverted Inside Constraint|
|8.|Weighted Distribution|
|9.|Bidirectional Constraint|
|10.|Implication Constraint|
|11.|if-else constraint|
|12.|foreach|
|13.|Solve before constraint|
|14.|Static Constraint|
|15.|Randomization methods|
|16.|Inline Constraint|
|17.|Soft Constraint|
|18.|Disable Constraint|
|19.|Disable Randomization|
|20.|randcase|
|21.|constraint memory examples|


***
  随机化有两种方式。  
1. 随机函数系统
2. 随机变量


***
 

## 1. 随机函数系统  
这个系统函数用于产生伪随机数。这些函数通常在 "initial begin" 块内部使用。通常使用两个系统函数，它们是 -
|$urandom()|$random()|$urandom_range()|
|:---------|:---------|:---------------|
|返回32位无符号随机数，但该数字在整个仿真过程中保持不变，除非我们改变种子数字。对于特定的种子数字，随机数再次固定，并且在整个仿真过程中不会改变。语法- $urandom()  | 返回32位有符号随机数，与 $urandom() 相同，在仿真过程中不会改变值，除非种子数字发生变化。语法- $random()| 对于给定的指定范围返回无符号值，并且在仿真时间内不会改变值。  语法 - $urandom(max,min);|
 
**示例： -**  

下面的示例显示了随机函数的代码。

```systemverilog
      a = $random();  
      b = $urandom();  
      c= $urandom_range(4,2); //GIVING RANGE (MAX,MIN)  
      d = $random(23); // assign some seed value  
      e = $urandom(4); // assign seed value  
      $display ("a=$random()      // Return 32 bit signed random variable");  
      $display("Random Value of a  =  %0d",a);    
      $display("b = $urandom()   // Return 32 bit unsigned random value .");    
      $display("Random Value of b = %0d",b);  
      $display ("c = $random_range(4,2)   // Return the unsigned random number") ;    
      $display("                          by giving the range to the variable");  
      $display("Random value of c = %0d",c);  
      $display(" $random(seed);     // assign some seed value, it will display 32 bit ");  
      $display ("                         signed random value for the given seed value ");  
      $display ("d = $random(23);  // Seed value =23");  
      $display ("Random value of d = %0d",d );  
      $display ("$urandom(seed);  // assign the seed value , it will display 32 bit ");  
      $display ("                    unsigned random value for the given seed value ");     
      $display ("e = $urandom(4);  // Seed value = 4;");  
      $display ("Random value of e = %0d", e);  
      end  
```

**输出快照**  
下面的输出，图 -1 显示了 $random()，$urandom() 的值，并显示了种子值的影响。

<img width="734" alt="cons_1" src="https://user-images.githubusercontent.com/110443268/190629477-ff70f07c-db95-4387-bdff-2b5ba7589cae.png">


**注意:**
* `seed` 是在随机化时给定的值，表示对于特定的种子，随机变量的值不应更改，并且使用 `-sv_seed<value>` 在 CMD 行中给出。
* 无论编译和运行文件多少次，都会再次给出相同的随机值。
* 如果希望在不同的时间获得不同的值，则更改种子。

***

## 2. 随机变量 
通常，随机变量是值未知的变量，或者是将值分配给每个实验结果的函数。
在随机化时获得随机值的类变量称为随机变量。随机变量的值在范围内均匀分布。
 
**随机变量的目的** 
当进行直接测试时，我们需要一些时间来考虑测试的可能条件或场景，并且有可能我们会漏掉一些测试用例。为了解决这个问题，引入了随机变量的概念。在随机变量中，将生成分配范围内的随机值。  
_随机函数的缺点是，它们不能在整个仿真时间内更改值。_

要使用随机变量，需要使用 rand 和 randc 类型修饰符关键字声明类变量。  

### rand 
rand 的性质是非循环的。它会随机给出任何值，并且可以在完成循环之前重复该值。
**语法**  
```systemverilog
rand data_type variable_name;
```

**示例：**  

下面的示例是随机变量的例子。

```systemverilog
      class rand_function;  
         rand logic [2:0] a ; 
      endclass  
      rand_function raf;  
        module rand_var;  
        initial begin  
        //  rand_function ra_f;  
        raf = new();  
       $display ("rand - Randomizing the value of the variable in the non-cycling form  ");  
       for (int i =0;i <= 10;i++)begin  
       void'(raf.randomize ());  
        $display("Iteration = %0d Random value of a = %0d",i, raf.a);  
       end  
      end  
```   
在上述代码中，类被声明为 rand_function，在其中声明了变量 'a'。随机变量 rand 用于随机化变量 'a' 的值。在模块内部，使用 randomize() 函数对类进行随机化。for 循环用于11次获取变量的随机值。

**输出快照**  
这里，输出显示了使用 rand 进行变量的随机化。

<img width="632" alt="cons_2" src="https://user-images.githubusercontent.com/110443268/190632351-751fcc5f-d868-4806-b9dc-0640bdde233e.png">


### randc  
randc 是随机循环的，在重复任何特定值之前会循环遍历其范围内的所有值。
randc 的性质是循环的。它会给出一个随机值，并在完成循环后重复它。

**语法**  
```systemverilog
randc data_type variable_name;
```

**示例**     

下面的示例是为 randc 变量。  

```systemverilog  
      class pack;  
        randc bit [2:0]a;  
      endclass  
      module randc_var;  
      pack pk=new();  
       initial begin  
        $display (" randc - It  is cyclic in nature . It will repeat ");  
        $display ("         it's value after completing one cycle .");     
       for (int i =0; i<=12;i++)begin  
       void'(pk.randomize ());  
        $display("Iteration =  %0d    Random Value =  %0d ", i ,pk.a);  
      end  
      end  
```
以上代码中，声明的类是包在其中声明的类变量是 a。使用 randc，变量 a 被随机化。在模块内，使用 randomize() 来随机化类，for 循环从 0 到 12 进行迭代。

**输出快照**   
下面的输出显示了使用 randc 进行变量的随机化。

<img width="569" alt="cons_3" src="https://user-images.githubusercontent.com/110443268/190633546-3f5186af-d62a-4ab5-9e17-4ec6376bedc3.png">


***
## 3.std::randomize
`std::randomize()` 也被称为 Scope-Randomize 函数。作用域随机化使您能够随机化不是类成员的变量，甚至可以使用下面所示的任一方法同时随机化多个变量。

作用域随机化通常用于没有使用 rand 函数声明的局部变量，用户还可以为其指定随机约束。甚至可以使用 “with” 子句接受内联约束。以下是声明 std::randomize 函数的一些语法。

**语法:**   
```systemverilog
std::randomize (variable);
std::randomize (variable) with { constraint's; };

std::randomize (variable-1, variable-2 ... variable-n);
std::randomize (variable-1, variable-2 ... variable-n) with { constraint's; };
```   

**示例：**     

```systemverilog
module std_random;
bit [3:0]a;
bit [3:0]b;
bit [3:0]c;
bit [3:0]d;
bit [3:0]e;
 initial begin
  repeat(4)begin
  void'( std ::randomize(a));
  $display("value of a  %d",a);
  void'(std::randomize(b) with  {b>6; a<12;});
  $display("value of b :%d",b);
  void'(std::randomize(c,d) with  {c<4; d<3;});
  $display("value of c :%d and d  %d ",c,d);
  void'(std::randomize(e) with  {e inside {[1:4]};});
   $display("value of e :%d ",e);
   end
 end
endmodule

```

在上面的例子中，我们声明了5个局部变量。这些变量使用 `std::randomize()` 进行了随机化，甚至可以通过将多个变量作为参数传递给 `randomize()` 函数，一次性随机化所有变量。我们还可以为随机化变量指定自己的内联约束条件。

这是随机化局部变量的一个优势，甚至在模块中，我们也可以像 `class_handle.randomize();` 一样，同时随机化多个变量。
**输出:**
![std_rand](https://user-images.githubusercontent.com/113417083/202613804-29e0ccb3-28e0-4f12-91da-bc38dffb5499.png)

### 在类中使用 std::randomize:

如果我们使用 `class_handle.randomize` 来随机化变量，只有那些类型为 `rand` 和 `randc` 的变量会被随机化。为了克服这一点，我们可以使用 `std::randomize(this)`，它将随机化该类的所有变量。但是，属于任何函数的局部变量不会被随机化，这是 `std::randomize()` 函数的主要缺点。对于这些局部变量，我们需要再次使用 `std` 函数进行随机化。

**示例:**   
```systemverilog
class test;
  int a;
  rand bit [2:0]b;
constraint c1 { a >= 2;a <= 9; }
 function void display();
  int c;
if (std::randomize(this));
  $display("using std_randomize %0d , %d",a,b);
   if (randomize(a))
     $display("randomize(a) %0d",a);
  if (std::randomize(a));
     $display("using std_randomize(a) %0d",a);
  if(std::randomize(b))
    $display("using std_randomize b: %0d",b);
  if (std::randomize(c) with {c>1;
                            c<4;})
     $display("using std_randomize with constraint,c: %0d",c);
 if (this.randomize());
      $display("this randomize %0d %d",a,b);

    endfunction

  endclass

 module tb;
test t;
 initial begin
  t=new();
repeat (3)
t.display();
end
endmodule
```

在这个例子中，我们在类 `test` 中声明了整型变量 `a` 和 `rand` 位类型变量 `b`，并在显示函数中声明了局部变量 `c`。所以，当我们使用 `std::randomize(this)` 时，只有 `a` 和 `b` 变量被随机化，而局部变量 `c` 没有被随机化。我们甚至可以使用 "with" 子句随机化局部变量并给出内联约束。

**输出:** 
![class_rand](https://user-images.githubusercontent.com/113417083/202614004-6be866f3-ce48-48a1-b1dc-418e7f355048.png)

从上面的输出中，我们可以看到 `std:randomize()` 的确切操作，这个函数严格适用于局部变量。尽管在类中为变量 `a` 定义了约束，`std::randomize(a)` 并不考虑那个全局约束，因为它完全依赖于其内联约束。由于 `std::randomize(a)` 没有内联约束，仿真器考虑了 `a` 的整个范围。

而对于变量 `c`，我们声明了一个范围在 1 到 4 之间的内联约束。因此，`c` 的输出在这个范围内。

**局限性:**
1. `std::randomize(variable)` 只考虑其内联约束，否则将考虑其声明的默认范围进行随机化。
2. `std::randomize(this)` 仅适用于随机化类变量。但这个函数不会考虑在任何函数中声明的局部变量，因此在随机化过程中有更大的可能遗漏某些数据。
3. `std::randomize(variable)` 仅适用于局部声明的变量。它不能在其他函数或类中访问。
***

## 4. 约束块

约束块是类似于函数和任务的类方法。约束在类中有一个唯一的名称。

**语法**
```systemverilog
constraint [constraint_name] {
  expression 1; 
  expression 2;  
  ... expression N;
}
```
约束块使用花括号括起来，而不是使用 `begin` 和 `end` 块。

**约束冲突**
约束块中的冲突在以下情况下出现：
1. 我们声明了多个具有相同名称的约束。
2. 给定约束的范围不匹配。

我们可以在类内和类外声明约束。要在类外声明约束，请使用 "extern" 关键字。

**在类块外声明约束**

![Untitled Diagram drawio (20)](https://user-images.githubusercontent.com/110443268/187884562-6e352c45-615b-4932-93d1-46d00eec0285.png)

如果在声明约束时不使用 `extern` 关键字，那么在编译时会显示警告。

* 在类外声明约束-
**语法**
```systemverilog
class class_name; 
  extern constraint constraint_name; 
endclass

constraint class_name::constraint_name {
  condition;
}
```

**示例**

下面的示例将展示如何使用 `extern` 关键字声明约束。在这里，声明了两个约束：`cons_name1` 和 `cons_name2`。`cons_name1` 在类的内部声明，而 `cons_name2` 使用 `extern` 关键字在类的外部声明。

```systemverilog
      class class_a;  
      rand byte a;  
      rand byte x;  
      constraint const_name1{a<6;  
                   a>2;}  
      extern constraint cons_name2;  
      endclass  
      constraint class_a:: cons_name2{x>7;}  
      module mod;  
      class_a pack;  
      initial begin  
      pack = new;  
      for (int i =0;i<=5;i++)begin  
      void'(pack.randomize());  
      $display ( "Iteration = %0d  Value of a = %0d Value of x = %0d  " , i,pack.a,pack.x);  
      end  
      end  
```
**输出截图**

输出图显示了使用外部约束对变量进行随机化的结果。

<img width="563" alt="cons_10" src="https://user-images.githubusercontent.com/110443268/191426898-5c66163a-fe09-4466-8b9f-7188b90d012c.png">


## 约束重写

**约束重写**

在这种约束重写中，如果在父类和子类中有相同的约束名称，那么我们可以说我们的约束在子类中使用子类句柄进行了重写。

**示例：**  

Let us understand through an example:  

```systemverilog
class parent;
  rand byte a;
  rand byte b;

  constraint cons{a==0;b==5;}
endclass:parent

class child extends parent;
  constraint cons{a==5;b==8;}
endclass:child


module top;
  initial begin
  child t1;
  t1= new;
  for(int i=0;i<3;i++)
  begin
    if (!t1.randomize()) begin
            $display("Randomization failed");
          end
   else begin
   $display("Iteration = %0d value of the a=%0d value of b=%0d",i,t1.a,t1.b);
end
end
end
endmodule:top   
```   
   
如果在父类和子类中使用了不同的约束名称，那么随机化会失败。因为子类是从父类继承而来的，所以我们不能在类中使用不同的约束名称。

如果我们想要重写约束，我们必须在父类和子类中使用相同的约束名称。然后我们可以轻松地从子类中覆盖父类的内容。

在上面的例子中，我们声明了一个名为父类的类，然后我们声明了一个扩展自父类的类。在父类内部，我们写了约束，即 a=0 和 b=5。然后在子类中，我们给变量 a 和 b 赋值为 a=5 和 b=8，两者都使用了相同的约束名称。然后我们创建了子类的句柄，并进行了随机化，此时父类的约束值被覆盖了。子类约束值的输出为 a=5 和 b=8。
  
  
**输出**  
  
![Untitled Diagram drawio (20)](https://user-images.githubusercontent.com/106074838/202632676-1da5e1b4-8e83-4c96-a2e5-aa2ba3f18bb3.png)  
  

在上述例子中，在3次迭代中，只有子类约束的值被执行，即 a=5 和 b=8。


***

## 5. 数组随机化
随机化也可以在数组数据类型中进行，比如静态数组、动态数组和队列。变量必须使用 `rand` 或 `randc` 类型声明，以启用变量的随机化。

### 静态数组随机化

在静态数组中，只能对数组元素进行随机化。由于大小是固定的，无法更改它。
将数组声明为关键字 `rand` 或 `randc`；在随机化时，数组的元素将获得随机值。

**示例 -1**
下面的示例展示了在不使用约束的情况下对一维静态数组进行随机化。

```systemverilog
class static_array;  
    randc byte a[5];  
endclass  

module stat_array;  
    static_array stat_arr;  

    initial begin  
        stat_arr = new();  
        $display ("静态数组 - 大小已经声明。因此，我们只能对其元素进行随机化。");  
        $display ("在随机化数组 'a' 的元素之前");  
        $display ("通过数组数据类型的默认值进行赋值。");  
        $display ("%0p", stat_arr.a);  
        void '(stat_arr.randomize ());  
        $display ("在随机化数组 'a' 的元素之后");  
        $display ("输出 = %0p ", stat_arr.a);   
    end  
endmodule  
```

以上代码声明了一个 byte 数据类型的数组 'a[5]'。随机化是通过使用随机化函数完成的。在不使用 void 的情况下，编译后，编译器会显示警告。在对类进行随机化后，将显示随机化的数组。

**输出截图**   

下图显示了在不使用约束的情况下对一个数组进行随机化的输出。

<img width="671" alt="cons_5" src="https://user-images.githubusercontent.com/110443268/190843990-17077350-b02a-4c75-8299-4580f5681380.png">

**示例： -2**-  

以下示例展示了在不使用约束的情况下对二维静态数组进行随机化。

```systemverilog
      class class_1;  
      rand bit [3:0]a[2][4];  
      endclass  
      module mod;  
      class_1 pack;  
      initial begin  
      pack = new;  
      $display ("The value elements of array before randomization = %0p",pack.a);  
      for (int i =0;i<=5;i++)begin  
      void'(pack.randomize());  
      $display ("The value of elements of array after randomization = %0p",pack.a);  
      end
      end   
```
以上代码中，声明的数组是 `a[2][4]`，每个元素大小为 4 位。在模块内部，使用 for 循环来进行更多次迭代。

**输出截图**  

下图显示了一个二维数组的随机化输出。
<img width="872" alt="cons_8" src="https://user-images.githubusercontent.com/110443268/190866664-ad77e697-fed4-476d-b0e8-033171262c8c.png">

  
**示例 -3**  
以下示例展示了使用约束对多维静态数组进行随机化。在约束内部，使用 foreach 循环为变量提供条件。在这里，数组随机化进行了6次。正如我们所看到的，所有元素的值都小于12。

```systemverilog
      class class_1;  
      rand bit [4:0]a[2:0][3:0];  
      constraint cons_name1{foreach (a[i,j])    // standard way to represent multidimensional array using  
                     a[i][j]<12;}           //foreach conditional statement  
       endclass  
       module mod;  
       class_1 pack;  
       initial begin  
         $display ("Randomization of multidimensional array");  
         $display ("----------------------------------------");  
        pack=new();  
        $display ("Before randomization");  
        $display (" Array = %0p",pack.a); // gives default value of data types .  
        $display ("After randomization");  
        void'(pack.randomize());  
        for (int i =0;i<=5;i++)begin  
        void'(pack.randomize());  
        $display (" Iteration = %0d, Array = %0p",i,pack.a);   
        end  
        end  
```    
**输出截图**  
以下图显示了使用约束对多维数组进行随机化。
<img width="663" alt="cons_11" src="https://user-images.githubusercontent.com/110443268/191428807-082a63a5-0997-4b64-bdf3-2b88ee2bbfab.png">

 
### 动态数组

动态数组在数组声明期间没有预定义的大小。通常，使用 `array_name.new()` 关键字来为动态数组分配大小。  
约束可以通过两种方式使用 -  
1. 使用约束块中的关键字 `size` 限制动态数组的大小。
2. 使用约束块中的 "foreach" 条件语句为动态数组的元素赋值。  

以下示例将展示如何随机化动态数组。

如果未约束大小，则随机化后的输出将是一个空数组。

**示例：**
```systemverilog  
class class_1;  
    randc bit [7:0] dyn_arr[];  
    // 声明一个动态数组，每个元素为 8 位。
    constraint dyn_arr_size { dyn_arr.size() > 3; dyn_arr.size() < 7; }  
    // 声明 dyn_arr 的大小在 3 到 7 之间
    constraint dyn_arr_ele { foreach (dyn_arr[i])   // 每个元素的值是索引号的平方。
                              dyn_arr[i] == i*i; }  
endclass  

module mod;  
    class_1 pack;  
    initial begin  
        pack = new();  
        for (int i = 0; i <= 2; i++) begin  
            void'(pack.randomize());   
            $display ("迭代次数 = %0d    数组 = %0p", i, pack.dyn_arr[i]);  
        end  
    end  
endmodule  
```

以上代码首先声明了一个动态数组 `dyn_arr[]`。在类内部声明一个用于给出大小范围的约束。在模块内部，使用 `randomize()` 函数来随机化类。使用约束将数组的大小限制在 3 到 7 之间。在随机化后，将显示输出 `(数组大小 + 1)` 次。

**输出截图**  
下面的输出是动态数组的随机化结果。

<img width="698" alt="cons_10" src="https://user-images.githubusercontent.com/110443268/192353232-517f89c5-536c-4440-ac19-a6b1d0b15981.png">


### 队列

队列的大小将根据大小约束进行随机化，并且队列元素将获得随机值。  
以下示例将展示如何随机化队列的元素。

**示例：**

以下示例展示了对队列元素进行随机化，并使用约束声明队列的大小。

```systemverilog
class class_1;
    rand bit [3:0] que[$];
    constraint que_const { que.size() == 5; }
endclass

module mod;
    class_1 pack;
    initial begin
        pack = new;
        for (int i = 0; i <= pack.que.size(); i++) begin
            void'(pack.randomize());
            $display ("迭代次数 = %0d  数组的值 = %0p", i, pack.que); 
        end
    end
endmodule
```  

***

## 6.约束内部

inside 关键字用于检查给定值是否在范围内。
inside 块中包含的值可以是变量、常量或范围。inside 结构包括上限和下限，并收集所有值，并以相等的概率选择值。
在 inside 块中，我们使用 inside 关键字，后跟大括号 `{}`。

**语法**

```systemverilog
constraint const_name { variable inside { values or range }; }
```

* **示例：**     
让我们以 inside 约束的示例来更好地理解。

```systemverilog
// 类声明
class PQR;
    // 使用 rand 关键字声明随机变量
    rand bit [3:0] var1;
    // 约束块
    constraint C1 { (var1 inside {[3:9]}); }
endclass

module top;
    initial begin
        int i;
        // 在此，我们需要创建一个句柄
        // 句柄名为 pkt
        PQR pqr;
        // 为句柄分配内存
        pqr = new();
        $display("------- inside 约束的输出 -------");
        $display("-----------------------------------");
        for (int i = 1; i < 7; i++) begin
            // 使用 .randomize() 函数随机化类对象的属性
            void'(pqr.randomize());
            $display("[%0t] @ 迭代次数：%0d -----> var1=%0d", $time, i, pqr.var1);
        end
        $display("-----------------------------------");
    end
endmodule
```

在上面的例子中，我们声明了一个类，类名为 PQR，在其中声明了变量 var1。在约束块中，我们使用 inside 关键字声明了一个范围，范围位于 3 和 9 之间。
在这里，随机值将在 3 和 9 之间打印。

**输出截图：**      
下图显示了 inside 约束的输出。

![fff drawio](https://user-images.githubusercontent.com/110447788/191229181-0b269a8a-9310-46f3-8b97-331a022af816.png)

在上面的示例中，我们声明了一个类，其中一个随机变量被声明为 var1。
在这里，我们使用 inside 关键字声明了一个范围，范围位于 3 和 9 之间。随机值将在 3 和 9 之间打印。

             
***

## 7.反转 inside 约束

反转 inside 是 inside 操作符的相反操作。只需在 inside 关键字前加上一个取反符号 **!** 即可实现。  
如果我们想生成一个不应该在一系列值范围内的值，那么我们可以使用带有否定的 inside 操作符。

**语法**    
```systemverilog
constraint const_name { !(variable inside { values or range }); }
```

**示例：**      
让我们以反转 inside 约束的示例来更好地理解。

```systemverilog
// 类声明
class PQR;
    // 使用 rand 关键字声明随机变量
    rand bit [3:0] var2;
    // 约束块
    // 在 inside 关键字前使用否定符号
    constraint C1 { !(var2 inside {[3:9]}); }
endclass

module top;
    initial begin
        int i;
        // 在此，我们需要创建一个句柄
        // 句柄名为 pkt
        PQR pqr;
        // 为句柄分配内存
        pqr = new();
        $display("----- 反转 inside 约束的输出 -----");
        $display("----------------------------------");
        for (int i = 1; i < 7; i++) begin
            // 使用 .randomize() 函数随机化类对象的属性
            void'(pqr.randomize());
            $display("[%0t] @ 迭代次数：%0d -----> var2=%0d", $time, i, pqr.var2);
        end
        $display("----------------------------------");
    end
endmodule
```

在上面的示例中，我们声明了一个类，类名为 PQR，在其中声明了变量 var2。在约束块中，我们使用带有否定的 inside 关键字声明了一个范围，范围位于 3 和 9 之间。如果我们想生成一个不应该在一系列值范围内的值，那么我们可以使用带有否定的 inside 操作符。在这里，由于使用了带有否定的 inside 关键字，将打印不在范围内的随机值。

**输出截图：**    
下图显示了反转 inside 约束的输出。

![fff-Page-2 drawio](https://user-images.githubusercontent.com/110447788/191229816-41c7a2a5-bb4a-4c2e-be51-ee747a4ea36c.png)

在上面的示例中，我们声明了一个类，在其中声明了一个随机变量 var2。在这里，由于使用了带有否定的 inside 关键字，将打印不在范围内的随机值。


***
## 8.加权分布

dist 操作符允许您创建加权分布。**dist** 是一个操作符，它接受一组值和权重，用 **:=** 或 **:/** 操作符分隔。
权重较大的值，在随机化中出现的频率更高。**dist** 操作符在需要加权分布的随机化时非常有用。

有两种类型的分布运算符

### 1.  := 操作符
:= 操作符将指定的权重分配给项目，或者如果项目是范围，则将指定的值分配给范围中的每个值。

**语法**

```systemverilog
value := weightage
```

 * **示例：**      
让我们以 := 操作符的示例来更好地理解。

```systemverilog
class myWorld;
    // 使用 rand 关键字声明随机变量
    rand bit [3:0] value1;
    // 约束块
    // 在这里，1 的权重为 30，6 的权重为 70，7 的权重为 20
    // 而 2 到 5 的权重为 40
    constraint m_var { value1 dist { 1:=30, [2:5]:=40, 6:=70, 7:=20 }; }
endclass
 
module top;
    initial begin
        int i;
        // 在此，我们需要创建一个句柄
        // 句柄名为 world
        myWorld world;
        // 为句柄分配内存
        world = new();
        $display("----- := 操作符的输出 -----");
        $display("6 的出现次数更多，因为 6 的权重更大");
        for(int i = 0; i < 10; i++) begin
            void'( world.randomize());
            $display("[%0t] @ 迭代次数 %0d  -----> value1=%0d", $time, i, world.value1);
        end
    end
endmodule
```

在这个例子中，1 的权重为 30，6 的权重为 70，7 的权重为 20，2 到 5 的权重为 40，总共为 280。
因此选择 1 的概率为 30/280，选择 6 的概率为 70/280，选择 7 的概率为 20/280，而选择 2 到 5 之间的值的概率为 40/280。在这个例子中，6 出现的次数更多，因为它的权重更高，被选择的概率更大。

 * **输出截图：**     
下图显示了使用 := 操作符的加权分布的输出。

![fff-Page-3 drawio](https://user-images.githubusercontent.com/110447788/191230064-f30d3653-31f6-4f48-b3c2-92ddeda93c39.png)

在上面的示例中，我们使用了 := 操作符。在这里，6 的权重比其他值更大。因此，6 出现的次数更多，因为 6 的权重更大。


### 2. :/ 操作符

:/ 操作符将指定的权重分配给项目，或者如果项目是范围，则将指定的权重分配给整个范围。如果范围中有 n 个值，则每个值的权重为 range_weight / n。

**语法**

```systemverilog
value :/ weightage
```

**示例：**      
让我们以 :/ 操作符的示例来更好地理解。

```systemverilog
// 类声明
class myWorld;
    // 使用 rand 关键字声明随机变量
    rand bit [3:0] value1;
    // 约束块
    // 在这里，1 的权重为 30，6 的权重为 40，7 的权重为 20
    // 而 2 到 5 共享总权重为 60，因此每个值的权重为 60/4
    constraint m_var { value1 dist { 1:/30, [2:5]:/60, 6:/40, 7:/20 }; } 
endclass

// 模块名为 top
module top;
    initial begin
        int i;
        // 在此，我们需要创建一个句柄
        // 句柄名为 world
        myWorld world;

        // 为句柄分配内存
        world = new();
        $display("----- :/ 操作符的输出 -----");
        $display("6 的出现次数更多，因为 6 的权重更大");
        $display("--------------------------------");
        for(int i = 0; i < 10; i++) begin
            void'( world.randomize());
            $display("[%0t] @ 迭代次数 %0d -----> value1=%0d", $time, i, world.value1);
        end
    end
endmodule
```

在这个例子中，1 的权重为 30，6 的权重为 40，7 的权重为 20，而 2 到 5 共享总权重为 60，因此每个值的权重为 60/4。  
因此选择 1 的概率为 30/150，选择 6 的概率为 40/150，选择 7 的概率为 20/150，而选择 2 到 5 之间的值的概率为 60/150。   
在这个例子中，6 出现的次数更多，因为它的权重更高。

* **输出截图：**  
下图显示了使用 :/ 操作符的加权分布的输出。

![fff-Page-4 drawio](https://user-images.githubusercontent.com/110447788/191232923-542605a3-fe78-4d93-b38f-e3ca2ee6a87d.png)

在上面的示例中，我们使用了 :/ 操作符，其中 6 的权重最高。在这里，'6' 的出现次数更多，因为 '6' 的权重比其他值更高。

***

## 9.双向约束

约束是双向解决的，这意味着所有随机变量的约束将并行解决。  
约束会并行解决所有随机变量，并确保没有约束失败。

**示例：**      
让我们以双向约束的示例来更好地理解。
```systemverilog
// 类声明
class items;
    // 使用 rand 关键字声明随机变量
    rand bit [3:0] value1;
    // 约束块
    constraint addr_mode1 { value1 > 5; value1 < 12; }
    constraint addr_mode2 { value1 > 6; }
endclass

// 模块名为 constraint_top
module constraint_top;
    initial begin
        int i;
        // 在此，我们需要创建一个句柄
        // 句柄名为 item
        items item;
        // 为句柄分配内存
        item = new();
        $display("----- 双向约束的输出 -----");
        $display("----- 约束 1 & 2 限制值为 7、8、9、10 和 11 -----");
        $display("----------------------------------------------");
        for (int i = 1; i < 10; i++) begin
            void'(item.randomize());
            $display("[%0t] @ 迭代次数 %0d -----> value1 = %0d", $time, i, item.value1);
        end
        $display("----------------------------------------------");
    end
endmodule
```      
在上面的示例中，我们声明了一个类，类名为 item，其中声明了变量 value1。在约束块中，我们对两个约束都给出了一些条件。所有随机变量的约束将并行解决。  
在这里，约束 1 和 2 限制值为 7、8、9、10 和 11。

**输出截图：**      
下图显示了双向约束的输出。

![gggg drawio](https://user-images.githubusercontent.com/110447788/192431625-2200812c-424e-4071-b2c9-2b29637b0ff6.png)

在上面的示例中，我们声明了一个类，在其中声明了一个随机变量 value1。  
在这里，约束 1 和 2 限制值为 7、8、9、10 和 11。


***

## 10.蕴涵约束

蕴涵运算符用于声明两个变量之间的条件关系。蕴涵运算符位于表达式和约束之间。

蕴涵运算符用符号 **->** 表示  

### 蕴涵运算符 

蕴涵运算符 **->** 用于约束表达式中显示两个变量之间的条件关系。蕴涵运算符位于表达式和约束之间。

如果蕴涵运算符 **->** 左侧的表达式为真，则将满足右侧的约束表达式。如果左侧不为真，则不考虑右侧表达式。

**语法：**        
```systemverilog
constraint const_name { (variable1) -> (variable2) }
```

 * **示例：**       
   让我们以蕴涵运算符的示例来更好地理解。  
```systemverilog
// 类声明
class ABC;
    // 使用 rand 关键字声明随机变量
    rand bit [2:0] value1;
    rand bit [3:0] value2;
    // 约束块
    // 蕴涵运算符用于指定两个变量 value1 和 value2 之间的条件
    constraint c_mode { (value1 inside {[1:5]}) -> (value2 < 8); }
endclass
// 模块名为 top
module top;
    initial begin
        int i;
        // 在此，我们需要声明一个句柄
        // 句柄名为 abc
        ABC abc;
        // 为句柄分配内存
        abc = new();
        $display("----- 蕴涵约束的输出 -----");
        $display("---------------------------------");
        for(int i = 0; i < 10; i++) begin
            void'(abc.randomize());
            $display("[%0t] @ 迭代次数 %0d -----> value1=%0d , value2=%0d", $time, i, abc.value1, abc.value2);
        end
        $display("---------------------------------");
    end
endmodule
```
在上面的示例中，我们声明了一个类，类名为 ABC，在其中声明了两个变量 value1 和 value2。在约束块中，使用 inside 关键字为 value1 声明了范围。   
在这里，如果 value1 处于 1 和 5 的范围内，则 value2 总是小于 8。  
如果 value1 不处于 1 和 5 的范围内，则 value2 总是大于 8。     

 * **输出截图：**    
下图显示了蕴涵约束的输出。

![fff-Page-7 drawio](https://user-images.githubusercontent.com/110447788/191240436-0fbc71179-7ffd-437e-8e0c-9bebfd59475e.png)

在上面的示例中，使用了蕴涵运算符，其中定义了两个随机变量 value1 和 value2。    
在这里，如果 value1 处于 1 和 5 的范围内，则 value2 总是小于 8。    
如果 value1 不处于 1 和 5 的范围内，则 value2 总是大于 8。

***

## 11.if-else Constraint
**if-else** 块允许约束的条件执行。如果表达式为真，则必须满足第一个约束块中的所有约束；否则，必须满足可选的 else 约束块中的所有约束。 


**示例：**      
让我们通过一个 if-else 约束的例子来更好地理解这一点。

```systemverilog
             // class declaration
             class basic;
             //value1 & value2 are the variables
             //random variables are created by rand keyword
             rand bit [3:0] value1;
             rand bit [2:0] value2;
             constraint c_var {
                              if(value1 inside {[4'h3:4'h9]})
                               value2 == 1;
                             else {
                                   value2 == 0;}
                            }
             endclass
             //module name is top
             module top;
             int i=1;
             initial begin
             //here, we need to create a handle
             //handle name is pkt
             basic pkt;
            // memory allocation to the handle
            pkt = new();
            $display("-----Output for if else constraint-----");
            $display("If the value1 lies between the 3 to 9, ");
            $display(" then value2 will be 1 otherwise 0 ");
            $display("-----------------------------------------------");
            for (int i=0;i<5;i++)begin
            void'( pkt.randomize());
            $display("[%0t] @ iteration %0d ----->  value1=%0d, value2 = %0d",$time,i,pkt.value1,pkt.value2);
            end
            $display("-----------------------------------------------");
            end
            endmodule
```
在上面的例子中，我们声明了一个名为 `basic` 的类，其中声明了两个变量 `value1` 和 `value2`。在约束块中，我们使用了 if-else 条件。

在 if 语句中，使用 `inside` 关键字为 `value1` 声明了一个范围，如果该范围在 3 到 9 之间，则 `value2` 将始终为 1；如果该范围不在 3 到 9 之间，则 `value2` 将始终为 0。



 **输出截图：**   

下图显示了 if-else 约束的输出结果。

![fff-Page-6 drawio (2)](https://user-images.githubusercontent.com/110447788/191235603-76cca8e3-926f-49da-ac08-9a18677a563a.png)


在上面的例子中，我们声明了一个类，其中声明了两个随机变量 `value1` 和 `value2`。

如果范围在 3 到 9 之间，则 `value2` 将始终为 1；如果范围不在 3 到 9 之间，则 `value2` 将始终为 0。


***

## 12.foreach constraint    
 
foreach 构造遍历数组的元素，并将每个元素的所有值分配给其索引。

foreach 循环遍历数组的元素，因此带有 foreach 循环的约束称为迭代约束。

 **语法：**      
```systemverilog
constraint constraint_name { foreach ( variable[iterator] )  variable[iterator] <..conditions..>  }
```

**示例：**      
让我们通过一个 foreach 约束的例子来更好地理解这一点。

```systemverilog
               //class declaration
               class value;
               //random variable declared using rand keyword 
               rand bit [3:0] s_array1[4];
               rand bit [3:0] s_array2[5];
               //constraint block
               //standard way to represent fixed array using  
               //foreach conditional statement  
               constraint cons {foreach(s_array1[i])
                                 s_array1[i]==i;
                                foreach (s_array2[i])
                                  s_array2[i] == i;}
               endclass
               // module name is top
               module top;
               initial begin
               //here,we need to declare handle
               //handle name is val
               value val;
              //memory allocation to the handle
              val = new();
              $display("-------------------------------");
              void'(val.randomize());
              $display("\t s_array1=%0p" , val.s_array1);
              $display("\t s_array2=%0p" , val.s_array2);
              $display("-------------------------------");
              end
              endmdule
```
在上面的例子中，我们声明了一个类，类名为 `value`，其中定义了两个固定数组。

在类内部声明了两个数组 `s_array1` 和 `s_array2`。这个约束将遍历数组中的每个元素，并将每个元素设置为其特定索引的值。


 **输出截图：**     

下图显示了 foreach 约束的输出结果。    

![fff-Page-8 drawio](https://user-images.githubusercontent.com/110447788/191323141-af0fbc8d-4923-4a90-aaf4-8e022372ec31.png)

***
## 13.Solve before Constraint 

这个约束属性在约束块中用于指定约束求解。如果变量是依赖的，因为约束是双向的，一个变量的值将影响另一个变量。这个 solve-before 可以通过强制约束求解器选择解决约束的顺序来改变概率分布。

**语法：** 
```systemverilog
constraint constraint_name {variable_1==1 -> variable_2==1;solve variable_1 before variable_2}
```  

让我们通过一个示例来更好地理解 solve-before 约束。

**示例:**   
```systemverilog
            class without_solve_before;  
            rand bit value1;  
            rand bit [3:0] value2;  
            constraint val {value1==1 -> value2==1;}  
            endclass  

          class with_solve_before;  
            rand bit value1;  
            rand bit [3:0] value2;  
            constraint valu {value1==1 -> value2==1;  
                            solve value1 before value2;}  
          endclass  

          module solve_before();  
             without_solve_before gen1 = new();  
             with_solve_before gen2 = new();  

            initial  
            begin  
              $write("%c[1;31m \t------Without solve before----------\n",27);  
              for(int i=1;i<=10;i++)  
              begin
                  void'(gen1.randomize());  
                  #1 $display("\t[%0t] @ iteration: %0d -----> value1: %0d \t value2: %0d",$time,i,gen1.value1,gen1.value2);  
              end  
              $write("\n%c[1;34m\t -----with solve before--------\n",27);  
              for(int i=1;i<=10;i++)  
              begin  
                  void'(gen2.randomize());  
                  #1 $display("\t[%0t] @ iteration: %0d -----> value1: %0d \t value2: %0d",$time,i,gen2.value1,gen2.value2);  
              end  
              $write("%c[0m",27);  
            end  

          endmodule : solve_before  
```

在上面的例子中，我们创建了两个类，分别命名为 `without_solve_before` 和 `with_solve_before`，它们分别拥有对象 `gen1` 和 `gen2`。它们都具有相同的约束，即如果 `value1` 为 1，则 `value2` 应该为 1。由于约束求解器是双向的，选择 `value2` 的概率也会影响选择 `value1` 的概率。

单独选择的概率为：
- `value1` 为 1 的概率是 1/2。
- `value2` 为 1 的概率是 1/16。 

**输出：**    

![solve before output 1](https://user-images.githubusercontent.com/110412468/191438631-cd63ca91-4176-4746-9f20-b741177498fc.png)


在上述输出中，前 32 次迭代是在没有使用 solve-before 的情况下进行的，接下来的 10 次迭代是在使用 solve-before 的情况下进行的。

没有 solve-before：同时考虑了 value1 和 value2 的约束，即 value1 取 1 的概率是 1/2，value2 取 1 的概率是 1/16，但要同时满足 value1 为 1 和 value2 为 1 的概率是 (1/2) * (1/16) = 1/32。

有 solve-before：在这种情况下，约束求解器首先随机确定 value1，然后根据 value1 来解决 value2。因此，获得 value1 为 1 的概率是 1/2。

因此，在前 32 次迭代中，只有 1 次迭代的 value1 为 1，即约为 **0.03%**，但使用 solve-before，则每隔一次迭代 value1 就会为 1，概率达到了 **50%**。


**限制：**

1.  can't use randc variables, as they were always allowed to solve first, if used then without solve-before is not considered.
2.  shouldn't have circular dependency i.e., solve value1 before value2 and solve value2 before value1, if so through error as shown below.  

![solve before error 1](https://user-images.githubusercontent.com/110412468/191438870-9644da50-c606-4c72-be1b-e28c98d8ad56.png)  

                      Fig.18 : Error of solve before 

         

***

##  14.Static Constraint  

static constraints are shared across all the objects of that class.  
A static constraint mode can be enabled or disabled by any object handle of that class which reflects in all the classes.  

**语法：**
```systemverilog
static constraint  constraint_name {constraint1;  
                                      constraint2;  
                                      ........   
                                      constraintN;}
```   
**示例:**   
```systemverilog
           class class1;
              rand bit [2:0] value;
              constraint cons {value==1;}
           endclass

           class class2;
              rand bit [2:0] value; 
              static constraint cons {value==1;}
           endclass
           
           initial
           begin
               object_1.cons.constraint_mode(0);
                for(int i=1;i<=3;i++)
                begin
                  void'(object_1.randomize());
                  void'(object_2.randomize());
                   #1 $display("\t[%0t] @ iteration: %0d -----> value in object_1: %0d  value in object_2: %0d",$time,i,object_1.value,object_2.value);
                end
           
               object_3.cons.constraint_mode(0);
                for(int i=1;i<=3;i++)
                begin
                  void'(object_3.randomize());
                  void'(object_4.randomize());
                   #1 $display("\t[%0t] @ iteration: %0d -----> value in object_3: %0d  value in object_4: %0d",$time,i,object_3.value,object_4.value);
                end
           end
```
In the above example, there were two classes named class1 & class2 with objects 1&2 for class1 and objects 3&4 for class2. Here the constraint for both classes is the same so the value should be always 1 if the constraint is on.  
If the constraint is off then the value will have other than 1.  

![static gif](https://user-images.githubusercontent.com/110412468/191321463-be83ae86-2f4b-49f5-9042-3c051330d1ed.gif)  

         gif 1. static constraint  

From the above gif, can say that if the non-static constraint is turned off/on by using a single object handle then the constraint is applicable to that particular object whereas in static constraint, if the constraint is turned off/on then it is applicable for every object of that class.

**输出：**     

![static constraint output 1 ](https://user-images.githubusercontent.com/110412468/191439132-d4bcfba3-0a7e-4a55-b329-cc0446021778.png)  

             Fig-:19 Output of static constraint output 
      
Class 1 has two objects 1&2 and class2 has objects 3&4.In class1 used non-static constraint, turned off in object 1 but still, the constraint is on in object 2, but used static constraint in class2, and turned off in object 3 then the constraint has been turned off in object 4 as well.

**Github code link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/static_constraint/static_constraint.sv   
**Github output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/static_constraint/static_constraint_log.log

***

##  15.Randomization Methods  

In general, there will be three randomize methods:  

* randomize();
* pre_randomize();
* post_randomize();  

![randomization diag 1](https://user-images.githubusercontent.com/110412468/191521969-bf7cd2c8-aa55-4074-a152-f86f390fa311.png)  

        gif 2: Randomization methods  

when a randomize function is called generates random values for variables that were declared as rand/randc by considering the constraints. It is a virtual function that is not overridable and on successful completion of randomization returns 1 else 0.

Actually, before performing the actual randomization, the simulator first enters into pre_randomize before randomizing, and then on successful randomization simulator enters into the post_randomize function which is also overridable. If the randomization fails due to any issues like constraint conflicts then the simulator doesn't enter into post_randomize and returns 0.  

### randomize:

randomize is a virtual function of int type returns 1 on successful completion else 0

**示例:**   

```systemverilog
 class generator;
  rand bit [2:0] value;
  constraint cons {value==5;}
endclass

module randomization();

   generator gen = new();
  initial
  begin

      $display("\tCalling Randomize....");
      if(gen.randomize())
        $display("\tvalue: %0d \tRandomization successful",gen.value);
      else
        $display("\tvalue: %0d \tRandomization Failed",gen.value);

        $display("\tCalling Randomize....");

      if(gen.randomize()with{value==2;})
        $display("\tvalue: %0d \tRandomization successful",gen.value);
      else
        $display("\tvalue: %0d \tRandomization Failed",gen.value);
  end
endmodule
``` 

**输出：**    

![randomization output](https://user-images.githubusercontent.com/110412468/191439901-f4af0390-cd63-4a2a-acf1-2d4179c49f4b.png) 

                       Fig-:20 Output of Randomization 

In the above example calling randomize function and after randomization was done taking constraint that value must be 5 if randomization is successful else prints randomization failed and the previous random value will be present in the variable.  
In the first randomization, there is no conflict so randomization completes successfully and returns 1 so if condition satisfies so prints as randomization successful, In the next call conflict between constraints so randomization doesn't complete so returns 0 so prints as randomization failed and has the previous random value i.e., 5.   

**Note:** **_If the randomization fails in the first iteration then the value of the variable will be the default value of the variable. If randomization fails after some successful randomization then the previous randomized value will be present in the variable._**

**Github code link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/randomization/randomization.sv

**Github output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/randomization/randomization_log.log  

### pre_randomize:

This is a void function type that can be overridable called before the actual randomization performs.

**语法：**
```systemverilog
function void pre_randomize();
```

**示例:**   
```systemverilog
          class generator;
               rand bit [2:0] value;
               constraint exp { value>5;}
  
               function void pre_randomize();
                  if(i%2==0)
                  begin
                     rand_mode(0);
                     $display("\tstopping randomization");
                  end
                  else
                     rand_mode(1);
                   i++;
               endfunction
         endclass

          module pre_randomization();
 
               generator gen = new();
 
              initial
              begin
 
                for(int i=1;i<=4;i++)
               begin
                 $display("\t[%0t]Calling Randomize....",$time);
                 void'(gen.randomize());
                 #1  $display("\t[%0t] @ iteration: %0d -----> value: %0d ",$time,i,gen.value);
               end
             end
           endmodule
```
**输出：**    

![pre randomization output](https://user-images.githubusercontent.com/110412468/191439947-5ee9b134-44a1-4c86-98e6-2eabd835bb3e.png)  

        Fig. 21 Output of Pre randomization

In the example, calling pre_randomize function and inside that, if condition satisfies then randomization is stopping in pre_randomize so simulator exits the randomize function without performing the randomization which means rand variables will have previous values. In iterations 1,3 randomization is stopped, so it has previous values but in iterations 2,4 randomization is done.  

**Github code link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/pre_randomization/pre_randomization.sv 
 
**Github output link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/pre_randomization/pre_randomization_log.log

### post_randomize:

This is also a void function type that can be overridable runs after the randomization is performed.

**syntax:** 
```systemverilog
function void post_randomize();
```

**示例:**   
```systemverilog
          function void pre_randomize();
               $display("\tI'm in pre_randomize function");
               check=0;
             endfunction
             function void post_randomize();
               $display("\tI'm in post_randomize function");
               check=1;
             endfunction  

             initial
                 begin
              
                     $display("\t[%0t]Calling Randomize....",$time);
                     check=gen.randomize();
                     #1  $display("\t[%0t] @ iteration: 1 -----> value: %0d ",$time,gen.value);
                     if(check==1)
                       $display("%c[1;32m\tRandomization is performed%c[0m",27,27);
                     else
                       $display("%c[1;31m\tRandomization is not performed%c[0m",27,27);
                     $display("\t[%0t]Calling Randomize....",$time);
                     check=gen.randomize()with{value<5;};
                      #1  $display("\t[%0t] @ iteration: 2  -----> value: %0d ",$time,gen.value);
                     if(check==1)
                       $display("%c[1;32m\tRandomization is performed%c[0m",27,27);
                     else
                       $display("%c[1;31m\tRandomization is not performed%c[0m",27,27);
 
                 end
```
**输出：**    

![post randomization](https://user-images.githubusercontent.com/110412468/191440019-e20a649e-83bf-40b6-b1d8-e75f6216db0a.png)  

        Fig.22 output of Post randomization  

In the first iteration of the example calling randomize function, there was no conflict so entering into both pre as well as post after randomizing so printed as randomization is successful but in the second iteration there was a conflict so randomization doesn't completes and comes back and printing as randomization is failed. 

**Github code link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/post_randomization/post_randomization.sv 

**Github output link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_methods/post_randomization/post_randomization_log.log

 
***

##  16.Inline Constraint 

Consider that some variables are needed to be randomized in 100 iterations but in the first 95 iterations user needs the common constraints, and in the last 5 iterations user wants to add some more constraints along with previous constraints, then instead of writing in different classes user can just add those extra constraints from where the randomization function is called using with the keyword as shown.

**syntax:** 

```systemverilog
obj_hndl.randomize()with{extra_constraints};
```  

These inline constraints just act as extra constraints by taking the previous constraints into consideration but not overriding the previous constraints.
For example, if variable >5 is declared in class and if added one more inline constraint as variable<10 then the final value of the variable will be between 5 and 10.

* Only inline constraint
* inline constraint along with class constraint
* inline conflict with class constraint 


### Only inline constraint  

**Example:**
```systemverilog
          class generator;
            rand bit [2:0] value;
          endclass

          module only_inline();
             generator gen = new();
            initial
            begin
              for(int i=1;i<=2;i++)
              begin
                void'(gen.randomize()with{value==3;});
                #1 $display("\t[%0t] @ iteration: %0d -----> value: %0d",$time,i,gen.value);
              end
            end
          endmodule
```

In the above example, there were no constraints in class so the value can be anywhere between 0 to 7 as it is 3-bit, but calling the randomize function along with inline constraint that value should be 3.

**输出：**    

![only inline](https://user-images.githubusercontent.com/110412468/191440392-7a05acc1-add4-4f86-801e-92fa9bf8859f.png)  

          Fig.23 output of only inline constraint 

As per the inline constraint, the value must be 3 so in both iterations the value is the same.


**Github code link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/only_inline/only_inline.sv 

**Github output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/only_inline/only_inline_log.log  

### inline constraint along with class constraint  

**示例:**  
```systemverilog
          class generator;
            rand bit [2:0] value;
            constraint exp { value>2;}
          endclass

          module inline_constraint();
             generator gen = new();
            initial
            begin
                void'(gen.randomize());
                #1 $display("\t[%0t] @ iteration: %0d -----> value: %0d",$time,i,gen.value);
                void'(gen.randomize()with{value==7;});
                #1 $display("\t[%0t] @ iteration: %0d -----> value: %0d",$time,i,gen.value);
            end
          endmodule
```
In the above example, the class has one constraint that the value should be greater than 2 and one more constraint is given through inline that the value should be 7.

**输出：**    

 
![class and inline output 1](https://user-images.githubusercontent.com/110412468/191521328-12507066-8ba1-4d81-b08c-ab7602dacb92.png)  

         Fig.24 output of inline constraint along with class constraint
  

The initial constraint in class is value >2 so its first iteration value is in the range of 2 to 7, but in the second  iteration giving value must be 7 from inline so the value is 7  

**Github code link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/class_and_inline/inline_constraint.sv  
**Github output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/class_and_inline/inline_constraint_log.log 


### inline conflict with class constraint 

**Example:**
```systemverilog
          class generator;
            rand bit [2:0] value;
            constraint cons {value==5;};
          endclass

          module conflict_with_inline();
             generator gen = new();
             int check;
            initial
            begin
              for(int i=1;i<=2;i++)
              begin
                check=gen.randomize()with{value==3;};
                if(check)
                  $display("\tRandomization Done \t @ iteration: %0d -----> value: %0d",i,gen.value);
                else
                  $display("\tRandomization Failed \t @ iteration: %0d -----> value: %0d",i,gen.value);
              end
            end
          endmodule
```  
In the above example, the class has a constraint that the value must be 5 and from the inline constraint, there was one more constraint mentioned that value should be 3.
**输出：**    

![conflict with inline](https://user-images.githubusercontent.com/110412468/191441019-b10913ac-5cf4-46fe-837d-754e52241359.png)  

           Fig.25 output of inline conflict with class constraint  

Here the constraint solver takes both the constraints into consideration which means there was a conflict between these constraints, in these times randomization will not happen and returns the value 0. so based on the check display message is printed.

**Github code link:**  https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/conflict_with_inline/conflict_with_inline.sv 
**Github output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/inline_constraints/conflict_with_inline/conflict_with_inline_log.log  

**note:**  
* Not throwing any error from Questa sim 10.6 version simulator
* In mentor graphics of 2021 version it's throwing an error that constraint conflict arose as shown below

![constraint_conflict_error_output](https://user-images.githubusercontent.com/110412468/191441854-7f18230c-ee58-4863-9ec5-9d7308701adb.png)  

             Fig. 26 Constraint conflict error  


## 17.Soft Constraint

Constraints declared with the keyword soft are called as soft constraints.  
If any conflict between class constraint and inline constraint leads to a randomization failure, it is clear that it is not possible to override the class constraint by using an inline constraint. So some test-case demand overrides the constraints, this can be done by using a soft keyword in class constraint.   

**Syntax**  
```systemverilog
constraint constraint_name { soft variable_name > range ; }
```  

**示例：**  
for a better understanding purpose, we are executing the two codes.
      
First Let's take an example for a better understanding of the normal constraints without using soft constraint
```systemverilog
        class pack;
        rand bit [0:3]a;
        constraint addr_a{a>5;}
        endclass

       module soft_without_conflict;

       pack pkh;
       initial begin

       pkh = new;
       $display("without using soft constraint output");
       for(int i =0; i<5;i++)
       begin
       void'(pkh.randomize());

       $display("\n \t a=%0d value =%0d",i,pkh.a);
       end
       pkh = new;
       $display("\n \t output of without conflict");
       for(int i =0; i<5;i++)
       begin
       void'(pkh.randomize()with {a<5;});
       $display("\n \t a=%0d value =%0d",i,pkh.a); 
       end
       end
       endmodule   
```
In the above example, we took a class name as pack which has an object pkh. the class has a constraint name called addr_a in that constraint is displayed from  0 to 5 value. and inside the module we are using inline constraint it will display from 0 to 10 values but we are using here inline constraint so This Constraint addr_a will be overridden.   

**输出截图**   
![Untitled Diagram drawio (10)](https://user-images.githubusercontent.com/106074838/191422207-28ddc66b-7969-4c12-a921-f2d2f1404339.png)  

               fig.27 Output of without soft constraint 

In the above example, in the starting 5 iterations normal constraints are executed so it displays the value from 5 to 15, and another 5 iterations inline constraint is executed so it displays the value from 10 to 0.    

**GitHub lab file link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/tree/production/constraints/soft_without_conflict

**GitHub log file link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/soft_without_conflict/soft_without_conflict_output.log 


Let's take an example for a better understanding of the Soft constraint  
```systemverilog
          class pack;
          rand bit [0:3]a;
          constraint addr_a{a>5;}
          endclass 

          module soft_with_conflict;
          pack pkh;
          initial begin

          pkh = new;
          $display("output of soft with conflict ");
          for(int i =0; i<5;i++)
          begin
          void'(pkh.randomize()with {a<5;});
          $display("\n \t a=%0d value =%0d",i,pkh.a);
          end
          pkh = new;
          $display("\n \t using soft constraint to solve conflict issue");
          for(int i =0; i<5;i++)
          begin
          void'(pkh.randomize()with {soft a<10;});

          $display("\n \t a=%0d value =%0d",i,pkh.a);
          end
          end
          endmodule 
``` 
In the above example, we took a class name as pack which has an object pkh. the class has a constraint name called addr_a in that constraint as to be displayed from  0 to 5 value but it's not displaying anything. and inside the module we are using inline constraint the is also not displaying anything because here the conflict will occur so resolve this conflict we are using a soft constraint. and it displays the value from 10 to 0 values.  

*  **Output Snap**  
![Untitled Diagram drawio (11)](https://user-images.githubusercontent.com/106074838/191422256-df39ba5d-6307-4c77-a79a-08cd4f814c11.png)


                fig 28. The output of soft with conflict  

In the above example, in the starting 5 iterations, normal constraints are executed so it displays the value zero because in the inside code already conflict occurred. another 5 iterations using soft constraints to execute the code, display the value from 10 to 0.  


**GitHub lab file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/soft_with_conflict/soft_with_conflict.sv

**GitHub log file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/soft_with_conflict/soft_with_conflict_output.log

***
###

## 18.Disable constraint 

Constraints in a class can be disabled using the **constraint_mode** method  
By default all the constraints will be enabled, during the randomization constraint user will not consider the disabled constraints.  

constraint_mode(1) means constraint block is enabled  
constraint_mode(0) means constraint block is disabled  
The default value of constraint_mode is 1, i.e enabled once the constraint block is disabled, it is required to make constraint_mode(1) enable back the constraint block. 

**语法：**
```systemverilog
object_handle.constraint_block_name.constraint_mode(enable);
```     
enable == 1, constraint block enable    
enable == 0, constraint block disable     


**示例：**  

Let's take an example for a better understanding of the disabled Constraint     
```systemverilog
            class packet;
            rand  bit [3:0] data;
            constraint data_range { data inside {5,10,15}; }
            endclass

            module constraint_mode;
            packet pkt = new();
            initial begin

           $display("If constraint is mode is 1 it will display the 5,10,15");
           $display("If constraint is mode is 0 it will display the random values");

           $display("\t Before Constraint disable");
           $display("\t Value of constraint mode = %0d",pkt.data_range.constraint_mode());
           void'( pkt.randomize());
           $display("\tdata = %0d",pkt.data);

           pkt.data_range.constraint_mode(0);

           $display("After Constraint disable");
           $display("Value of constraint mode = %0d",pkt.data_range.constraint_mode());

           repeat(5) begin
           void'(pkt.randomize());
           $display("\tdata = %0d",pkt.data);
           end
           end
           endmodule   
```
In the above example, we took a class name as packet which has an object pkt. the class has a constraint name called data_range in that constraint will be displayed 5, 10, 15. constraint mode is enabled (1) it displays the values 5, 10, and 15 and if constraint mode is disabled (0) it displays any values.    

**输出截图**  

![Untitled Diagram drawio](https://user-images.githubusercontent.com/106074838/191422774-ad3860d7-13a8-4f60-b226-e9e810679f6b.png)  

             fig 29. The output of Disable constraint 
 
In the above output, If constraint mode is 1 it displays 5,10,15, and if disabled the constraint using constraint mode is 0 then it displays the any random values.   

**GitHub lab file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_mode/constraint_mode_code.sv

**GitHub log file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_mode/constraint_mode_code_output.log

***

## 19.Disable randomization  

The rand_mode() method is used to disable the randomization of a variable declared with the rand/randc keyword.   
    
   rand_mode(1) means randomization enabled  
   rand_mode(0) means randomization disabled  
   The default value of rand_mode is 1, i.e enabled  
    
Once the randomization is disabled, it is required to make rand_mode(1) enable back the randomization
rand_mode can be called as SystemVerilog method, the randomization enables/disable status of a variable can be obtained by calling variable.rand_mode().  
the rand_mode method returns 1 if randomization is enabled else returns 0  

**Syntax**  

```systemverilog
object_hanlde.variable_name.rand_mode(enable);  
//enable = 1, randomization enable  
//enable = 0, randomization disable   
```
**示例：**  

Let's take an example for a better understanding of the disable randomization   
```
      class packet;
      rand bit [2:0]data1;
      randc bit [1:0]data2;
      int state;
      function rand_mode1(int a);
      if(a==0)
      begin
        rand_mode(a);
        state = a;
      end
      else if(a==1)
      begin
        rand_mode(a);
        state = a;
     end
     endfunction
     endclass

     module randomization_mode;
     packet pkt = new();
     int c;
     initial begin
     $display("Before Randomization data1 = %0d data2= %0d",pkt.data1,pkt.data2);

     if(pkt.data1.rand_mode())
     if (pkt.data2.rand_mode())
        pkt.state = 1;
        $display("randomization of all variables are enabled");

        for(int i = 0;i<5;i++)
        begin
          c = pkt.randomize();
          $display("[%0d] After enable the randomizations data1 =%0d, data2 = %0d",i,pkt.data1,pkt.data2);
          $display("[%0d] state = %0d",i,pkt.state);
          if(i==3)
          begin
            pkt.rand_mode1(0);
            $display("[%0d] state = %0d",i,pkt.state);
          end
          $display("[%0d] After disable in the randomization data1 =%0d, data2 = %0d",i,pkt.data1,pkt.data2);
        end
      end
     endmodule  
```
In the above example, we took a class name as packet which has an object pkt. inside the class, we are declaring a function name called rand_mode1 which has the variable is state. if state = 1 randomization enabled, state = 0 randomization disabled.  
we were declaring the output 0 to 5 variations, in that 0 to 3, enable randomization and disable randomization both randomization has happened. and remaining 4 & 5 variations only randomization happens.   

**Output snap**   
![Untitled Diagram drawio (12)](https://user-images.githubusercontent.com/106074838/191422847-50352caa-f6f3-4e0e-83cd-4c99b4e41031.png)

                  Fig.30 The output of Disable randomization  

In the above output, using Randomization mode is 1 to enable the randomization, then it will display the random data . using randomization mode is 0 to disable the randomization, then it displays the zero or previous randomization data. In our output snap, iterations from 0 to 3 both randomization enable 
 disable are happening and in iteration 4 only randomization disable is happening.     

**GitHub lab file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_mode/randomization_mode_code.sv

**GitHub log file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randomization_mode/randomization_mode_code_output.log 

***

## 20.randcase   

The keyword randcase introduces a case statement that randomly selects one its of branches.  

The case item expressions are positive integer values that represent the weights associated with each item.  
The probability of selecting an item is derived by the division of that item's weight divided by the sum of all weights.  

**Syntax**  

```systemverilog
randcase  
item: statement   
endcase
```  

**Example**  

Let's take an example for a better understanding of the randcase      
```systemverilog
    module r_case;
    initial begin
     $display("Random data will be generated by simulator");
     $display("data from 0 to 3 then it will display randcase output");
     for(int i =0; i<6;i++)
     begin
     randcase
     0:$display("\t \n output of randcase 0");
     1:$display("\t \n output of randcase 1");
     2:$display("\t \n output of randcase 2");
     3:$display("\t \n output of randcase 3");
     endcase
     end
     end
     endmodule  
```
In the above example, we were using randcase, if its expressions match it displays. Each call to **randcase** retrieves one random number in the range of 0 to the sum of the weights. the weights are then selected in declaration order of small random numbers corresponding to the first (top) weight statements. 

**Output snap**  
![Untitled Diagram drawio (13)](https://user-images.githubusercontent.com/106074838/191423224-4f4560e1-ac94-4808-93e2-e595ae21aa44.png)
 
               Fig.31 output of the randcase
 
In the above output, using randcase to generate the 0 to 3 values if any expressions is match it displays outputs.  
In the above-output snap, the sum of all weights is 6; therefore, the probability of taking the first branch is (1/6) i.e. 0.166.
The probability of taking the second is (2/6) i.e. 0.33, and the probability of taking the third is (3/6) i.e. 0.5. Each call to the randcase statement will return a random number in the range from 0 to 3.  
  

**GitHub lab file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randcase/randcase_code.sv 

**GitHub log file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/randcase/randcase_code_output.log 

***


## Memory partition using constraints

### Memory block randomization

Assume that you have a memory of size 2048 i.e., 2KB in design to store some data, then if we need some block of that 2KB memory for some purpose, for partitioning that memory we can use constraints.

**Example:**
```systemverilog
          class memory_block;
            bit [31:0] mem_ram_start,mem_ram_end;
            rand bit [31:0] mem_start_addr,mem_end_addr;
            rand int mem_block_size;
            constraint mem {mem_start_addr>=mem_ram_start;
                            mem_start_addr<mem_ram_end;
                            mem_start_addr%4==0;
                            mem_end_addr==mem_start_addr+mem_block_size-1;}

            constraint block_size {mem_block_size inside {32,64};}

            function void display();
              $display("\t----memory block----");
              $display("\t RAM start addr : %0d",mem_ram_start);
              $display("\t RAM end addr : %0d",mem_ram_end);
              $display("\t BLOCK start addr : %0d",mem_start_addr);
              $display("\t BLOCK end addr : %0d",mem_end_addr);
              $display("\t BLOCK SIZE:%0d",mem_block_size);
            endfunction

          endclass

          module single_memory_block();
            memory_block memb =new();
            initial
            begin
              memb.mem_ram_start=32'h0;
              memb.mem_ram_end=32'h7ff;
              void'(memb.randomize());
              memb.display();
            end
          endmodule
```
In the above example,we took start address is 0 and end address is 2047, and gave constraints such that the block size should be of either 32, 64(int).The block should start at multiple of 4 and should end depending on the block_size.

**输出：**    

![single memory output](https://user-images.githubusercontent.com/110412468/191540532-a0b26722-914a-4916-b099-3674aaf5df03.png)  

![single mem](https://user-images.githubusercontent.com/110412468/191540633-9194f978-16df-4e0d-b355-6c517d527f42.png)

          Fig. 32. output of the Memory block randomization

The output of the above example is shown in above diagram, for constraint of block size , solver gave 64.Based on this block size the solver will give a start address such that the memory block will be within the range of 2KB. here gave it as 1896 which is multiple of 4 and from there 64 it will be 1959 as end address.

**GitHub lab file link** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/single_memory_block/single_memory_block.sv  

**GitHub log file link ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/single_memory_block/single_memory_block_log.log  

***

### Memory n equal partitions 

Here we will try to divide the given memory into n equal parts of partitions.

**Example:**
```systemverilog
          class memory_block;
            bit [31:0] mem_ram_start,mem_ram_end;
            rand int mem_num_parts,mem_part_size;
            rand bit [31:0] mem_part_start[];
            constraint parts {mem_num_parts>=2;
                              mem_num_parts<=8;}

            constraint part_size {mem_part_size==(mem_ram_end-mem_ram_start)/mem_num_parts+1;}

            constraint patition {mem_part_start.size()==mem_num_parts;
                                 foreach(mem_part_start[i])
                                 if(i)
                                   mem_part_start[i]==mem_part_start[i-1]+mem_part_size;
                                 else
                                  mem_part_start[i]==mem_ram_start;}
            function display();
              $display("\t RAM start addr : %0d ",mem_ram_start);
              $display("\t RAM end addr : %0d ",mem_ram_end);
              $display("\t No of Partitions : %0d ",mem_num_parts);
              $display("\t Size of each partition : %0d ",mem_part_size);
              $display("\n\t -----------partitions----------- ");
              foreach(mem_part_start[i])
              begin
                if(i==mem_num_parts-1)
                   $display("\t Partition : %0d from %0d to %0d "\ 
                              ,i+1,mem_part_start[i],mem_ram_end);
                else
                   $display("\t Partition : %0d from %0d to %0d "\
                   ,i+1,mem_part_start[i],mem_part_start[i+1]-1);
              end
          endfunction

          endclass


          module memory_n_equal_partitions();
              memory_block memb=new();
            initial
            begin
              memb.mem_ram_start=32'h0;
              memb.mem_ram_end=32'h7ff;
              void'(memb.randomize());
              void'(memb.display());
            end
          endmodule  
```
In the above example, we have taken a memory of 2KB and tried to make it into n equal partitions.  

output:  

![mem n equal parts](https://user-images.githubusercontent.com/110412468/191571884-5e245db2-a4dd-487a-8041-d7f0cfadbba7.png)  


![n equal](https://user-images.githubusercontent.com/110412468/191571964-483c6f9e-787d-47a7-bd10-e6a152df9c94.png)

          Fig.33. output of the Memory n equal partitions  

All the constraints are solved in parallel, here let's say first took a number between 2 & 8 i.e., 7 in this case, and then divide the whole memory by 7 i.e., 293 which will be almost equal to 2KB. Here we tried to assign the start address of every part using the array and each part with space 293 each.  

**Github lab code link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_equal_partitions/memory_n_equal_partitions.sv

**Github lab output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_equal_partitions/memory_n_equal_partitions_log.log


***

### Memory n variable partitions 

In the following example, we are trying to divide one block of memory into n partitions but need not to be equal.

Example:
```systemverilog
          class memory_block;
            bit [31:0] mem_ram_start,mem_ram_end;
            rand int mem_num_parts,mem_part_size[];
            rand bit [31:0] mem_part_start[];
            constraint parts {mem_num_parts>=2;
                              mem_num_parts<=8;}
            constraint part_sizes {mem_part_size.size()==mem_num_parts;
                                   mem_part_size.sum()==mem_ram_end-mem_ram_start+1;
                                   foreach(mem_part_size[i])
                                     mem_part_size[i] inside {16,32,64,128,256,512,1024,2048,4096};
                                   }
            constraint partition {mem_part_start.size()==mem_num_parts;
                                  foreach(mem_part_start[i])
                                  if(i)
                                   mem_part_start[i]==mem_part_start[i-1]+mem_part_size[i-1];
                                  else
                                   mem_part_start[i]==mem_ram_start;}
            function display();
              $display("\t RAM start addr : %0d ",mem_ram_start);
              $display("\t RAM end addr : %0d ",mem_ram_end);
              $display("\t No of Partitions : %0d ",mem_num_parts);
              $display("\n\t -----------partitions-----------");
              foreach(mem_part_start[i])
              begin
                if(i==mem_num_parts-1)
                $display("\t Partition : %0d with size :%0d from %0d to %0d "\
                          ,i,mem_part_size[i],mem_part_start[i],mem_ram_end);
                else
                $display("\t Partition : %0d with size :%0d from %0d to %0d "\
                          ,i,mem_part_size[i],mem_part_start[i],mem_part_start[i+1]-1);
              end
          endfunction
          endclass

          module memory_n_var_partitions();
              memory_block memb=new();
            initial
            begin
              memb.mem_ram_start=32'h0;
              memb.mem_ram_end=32'h3fff;
              void'(memb.randomize());
              void'(memb.display());
            end
          endmodule  
```
Here the memory size given is 16KB, then taking a constraint to divide by n parts i.e., 8 parts in this example. One more constraint is given such that the total sum of all the n variant partitions and allocated the particular sizes for partitions using foreach constraint.The divisions of the partitions are shown in the following diagram.

**输出：**    

![mem n var parts output](https://user-images.githubusercontent.com/110412468/191576440-c50754f1-f41c-4a9b-98d3-76d16bf96a0c.png)  

![mem n var parts](https://user-images.githubusercontent.com/110412468/191576490-3d26a98a-6813-491a-924c-1417107d3da8.png)  

          Fig.34. the output of the Memory n variable partitions 

**Github lab code link: ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_var_partitions/memory_n_var_partitions.sv

**Github lab output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_n_var_partitions/memory_n_var_partitions_log.log

***

### Memory partitions with spaces in between  

In this example, it was similar to the previous example like dividing n variable partitions but here adding space parts also in between the partitions .

**示例:**   
```systemverilog
          class memory_block;
            bit [31:0] mem_ram_start,mem_ram_end;
            rand int mem_num_parts,mem_part_size[],mem_space[];
            rand bit [31:0] mem_part_start[];
            constraint parts {mem_num_parts>4;
                              mem_num_parts<10;}
            constraint part_sizes {mem_part_size.size()==mem_num_parts;
                                   mem_space.size()==mem_num_parts-1;
                                   mem_part_size.sum()+mem_space.sum()==mem_ram_end-mem_ram_start+1;
                                   foreach(mem_part_size[i])
                                   {
                                      mem_part_size[i] inside {256,512,1024,2048};
                                      if(i<mem_space.size())
                                        mem_space[i] inside {64,256,512,1024};
                                    }
                                   }
            constraint partition {mem_part_start.size()==mem_num_parts;
                                  foreach(mem_part_start[i])
                                  if(i)
                                   mem_part_start[i]==mem_part_start[i-1]+mem_part_size[i-1];
                                  else
                                   mem_part_start[i]==mem_ram_start;}
            function display();
              $display("\tRAM start addr : %0d ",mem_ram_start);
              $display("\tRAM end addr : %0d ",mem_ram_end);
              $display("\tNo of Partitions : %0d ",mem_num_parts);
              $display("\tmem_part_size : %0p",mem_part_size);
              $display("\tmem_space : %0p",mem_space);
              $display("\n\t %c[1;32m-----------%c[1;34mpartitions%c[1;32m------------%c[0m",27,27,27,27);
              foreach(mem_part_start[i])
              begin
                if(i==mem_num_parts-1)
                $display("\t%c[0;34m Partition : %0d with size :%0d from %0d to %0d %c[0m\n"
                           ,27,i,mem_part_size[i],mem_part_start[i]+mem_space[i-1],mem_ram_end,27);
                else if(i==0)
                  $display("\t%c[0;34m Partition : %0d with size :%0d from %0d to %0d %c[1;31m
                             \n\t\tspace_part : %0d bytes ",27,i,mem_part_size[i],mem_part_start[i],
                             mem_part_start[i+1]-1,27,mem_space[i]);
      else
         $display("\t%c[0;34m Partition : %0d with size :%0d from %0d to %0d %c[1;31m 
                    \n\t\tspace_part : %0d bytes",27,i,mem_part_size[i],
                    mem_part_start[i]+mem_space[i-1],mem_part_start[i+1]-1,27,mem_space[i]);

                end          
          endfunction
          endclass


          module memory_partition_with_spaces();
              memory_block memb=new();
            initial
            begin
              memb.mem_ram_start=32'h0;
              memb.mem_ram_end=32'h23ff;
              void'(memb.randomize()with{mem_num_parts==5;});
              void'(memb.display());
          end
          endmodule
```
In the above example, memory is 9KB, we have taken 5 memory parts as inline constraints and space partition between every two parts, which means the total will be 9 parts. Here we are taking those all parts sum should be equal to 9215. The starting addresses of the memory partition are stored in one array and assigned different sizes using inside constraints and the same with the parts of the space also. The final memory block looks like the following diagram. If any of the constraints is not satisfying then there will be no randomization done and every value will be having default value i.e., 0

**输出：**    

![mem with spaces output](https://user-images.githubusercontent.com/110412468/191585917-609bf833-825b-4eb0-9d39-727a5427a86b.png)  

![mem spaces](https://user-images.githubusercontent.com/110412468/191585941-95846a19-a196-4ba1-b3bc-6fbdc1a5ce37.png)  

         Fig.35. Output of the  Memory partitions with spaces in between  

**Github lab code link: ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_partition_with_spaces/memory_partition_with_spaces.sv

**Github lab output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_partition_with_spaces/memory_partition_with_spaces_log.log



***

### Partitions for program and data

In the following example, memory is made into n partitions of program and data and spaces in between 

**Example:**
```systemverilog
          class memory_block;
            int total_mem;
            rand int pgm[],data[],space[];
            rand int max_pgms,max_pgm_size,max_data_size;
            rand int num_pgm,num_data,num_space;
          
            constraint nums {num_pgm inside {[1:max_pgms]};
                             num_data inside {[1:10]};
                             num_space inside {[1:10]};}

            constraint maxs {max_pgms==10;
                             max_pgm_size==512;
                             max_data_size==128;}

            constraint arrays {pgm.size()==num_pgm;
                               data.size()==num_data;
                               space.size()==num_space;}

            constraint ram {foreach(pgm[i])
                                {
                                  pgm[i] dist {[128:512]:=75,[32:64]:/20};
                                   pgm[i]%4 ==0;
                                }
                            foreach(data[i])
                              {
                                 data[i] inside {64};
                              }

                            foreach(space[i])
                                {
                                 space[i] inside {64,128,512};
                                }
                          total_mem == pgm.sum()+data.sum()+space.sum();
                              }

            function void display();          
              $display("\tTotal_RAM : %0d ",total_mem);
              $display("\tNo.of Programs : %0d ",num_pgm);
              $display("\tNo.of data's : %0d ",num_data);
              $display("\tNo.of space's : %0d ",num_space);
              $display("\tTotal_program_size : %0d , Total_data_size :\
                         %0d Total_space_size : %0d \n",pgm.sum(),data.sum(),space.sum());
              foreach(pgm[i])
                $display("\t %c[1;32m Program_%0d is of %0d bytes %c[0m",27,i,pgm[i],27);
              foreach(data[i])
                $display("\t %c[1;33m data_%0d is of %0d bytes %c[0m",27,i,data[i],27);
              foreach(space[i])
                $display("\t %c[1;34m space_%0d is of %0d bytes %c[0m",27,i,space[i],27);
            endfunction
          endclass


          module memory_pgm_data();          
            memory_block mb;
            initial
            begin
              mb =new();
              mb.total_mem=6144;
              void'(mb.randomize());
              mb.display();
            end

          endmodule
```
In this, we have used constraints such that the total programs, data, and space of all sizes should be equal to the size of the memory block of 6KB.here we gave the constraints to choose the number of program blocks, data blocks, and space blocks. here it came as 10 programs, 2 data blocks, and 5 space blocks. And also the program, space, and data sizes are assigned using foreach and inside constraints.If any of the constraints fails then the whole randomization will be stopped.

**输出：**    

![mem prgrm space output](https://user-images.githubusercontent.com/110412468/191595367-2c614be3-d9c4-4b26-83c6-dc57e4d45976.png)  

             Fig.36. Output of the  Partitions for program and data  

**Github lab code link: ** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_program_data/memory_pgm_data.sv

**Github lab output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/constraints/constraint_memory_examples/memory_program_data/memory_pgm_data_log.log




 




 






  
 

 


 







 







 


## 