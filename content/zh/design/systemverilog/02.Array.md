---
title: "SystemVerilog 数组"
categories: ["SystemVerilog"]
tags: "sv"
weight: 2
---

# 数组

数组是元素的集合，所有元素都具有相同的类型，并使用其名称和一个或多个索引进行访问。 Verilog 2001 要求数组的下限和上限必须是数组声明的一部分。 System Verilog 引入了紧凑数组声明样式，只需给出数组大小以及数组名称声明就足够了。

下图显示了 System Verilog 中使用的不同类型的数组。
![arrays_sv](https://user-images.githubusercontent.com/110448056/187371213-6de08da7-079a-4a4c-974b-9cc3304ae162.png)

                                                     Fig.1 Types of arrays in SV

## 数组列表

**Sr No.** | **数组类型**         | **描述**                                                                   | 
|---|------------------------------------------ | -------------------------------------------------------------------------------------|
1|合并数组(Packed Array) | 先声明数组名称，后声明数组维度 |       
2|非合并数组(Unpacked Array) | 先声明数组维度，后声明数组名称 | 
3|动态数组(Dynamic Array)| 内存将在运行时分配 |
4|关联数组(Associative Array) | Memories allocated only when it is used and any index type is used for indexing the array |
5|队列(Queue)| It is similar to fifo and we can add and remove elements from queue at run time |
6 | 数组操作函数 | 它由数组定位函数、数组排序函数和数组缩减函数组成  |
                                       Table.1. Array cheat sheet

## 静态数组（固定大小数组）：
在固定大小数组/静态数组中，数组大小在整个模拟过程中将保持不变，一旦声明数组就无需创建它。默认情况下，数组将初始化为值“0”。在这种类型的数组中，内存将在编译阶段被占用，并且我们无法在运行时重新分配内存。

## Static arrays has two types:   
1) 合并数组   
2) 非合并数组.

---

### 1.合并数组 Packed Arrays:
合并数组是一种在数组名称之前声明数组维度的数组。在此数组中的多个位存储在一个内存位置中。

**注意：** 它可以由任何单个位数据类型 bit、logic 和 reg 组成。我们不能对合并数组使用多位数据类型。
 
**语法:-** `[data_type] [dimensions] [array_name];`

**示例,** 

`1) bit [3:0]abc = 4'b0110`  
`2) logic [15:0]pqr = 16'h10fe`  
`3) reg [7:0]xyz = 8'd16`

**一些注意事项：**

*  如果合并数组被声明为带符号的，则被视为单个向量的数组应被带符号。数组的各个元素都是无符号的，除非它们是声明为有符号的命名类型。
* 合并数组的最大大小可以受到限制，但至少应为 65536 (2^16) 位。
* 合并数组是可综合的。

---
 
下图展示了二维合并数组中数组元素的存储方式。对于位 [2:0][3:0]xyz 示例，数组元素从左到右将占用内存。


![2d-packed](https://user-images.githubusercontent.com/110448056/187356323-2d671f63-2de6-4082-938f-c43ea6724534.png)

                                 Figure.3 two dimensional packed array memory layout

---

**合并数组的应用：**

它们用于存储可以执行位选择和部分选择操作的数据包结构。

---

### 2.非合并数组 Unpacked Arrays:

非合并数组是在数组名称之后声明数组维度的数组。在此，多个位将存储在不同的存储位置中。


**语法:-**  `[data_type] [array_name] [dimension];`

**示例,** 

`byte a[8] = '{4,5,6,2,3,7,9,10}`

`int abc[10] = $urandom_range(10,50);` 

其中，$urandom_range是内置函数，它生成10到50之间的随机数。

**一些注意事项：**

* 它们可以是任何数据类型。
* 如果非合并数组被声明为有符号，则这适用于数组的各个元素，因为整个数组不能被视为单个向量。
* 非合并数组可以以模拟器选择的任何方式排列在内存中——不必是连续的。
* 它们可以是固定大小的数组、动态数组、关联数组或队列。
* 非合并数组是不可综合的。

---
下图显示了数组元素如何存储在二维非合并数组中。对于 int abc[2][3] 示例，数组元素从左到右将占用内存。

![2d-unpacked](https://user-images.githubusercontent.com/110448056/190572695-27a9bd88-04a6-4fdf-a6af-68a9fb986244.png)

                                   Figure.6 two dimensional unpacked array memory layout


---

**非合并数组的应用：**

它们用于对随机存取存储器 (RAM)、只读存储器 (ROM) 和一次访问一个元素的寄存器文件进行建模。

---

## 混合多维数组：

合并数组和非合并数组的混合称为混合多维数组。 

**语法:-**  `[data_type] [dimensions] [array_name] [dimensions];`

**示例,** 

`logic [2:0][3:0] mixed_array [2:0][3:0];`

**一些注意事项：**

* 首先按从最左边到最右边的顺序引用所有非合并数组
* 然后按从最左边到最右边的顺序引用所有合并数组。

在给定的示例中，将从左到右分配内存，并且对于第一个非合并数组维度将被考虑，如下图所示，然后考虑合并数组维度。

![mixed-arrays](https://user-images.githubusercontent.com/110448056/190611850-07ad5b94-e594-44c8-a107-5aeb3768a508.png)

                               Figure.7 mixed multi dimensional array memory allocation-
--- 

## 3. 动态数组 Dynamic Arrays:

动态数组是非合并的数组，其大小可以在运行时设置或更改。动态数组的空间在运行时显式创建之前并不存在。

**语法:-** `<data_type> array_name []`

**示例,**

`int abc[] = new[7];`

`abc[7] = '{11,12,13,14,15,16,17};`

**一些注意事项：**

* 未初始化的动态数组的默认大小为 0。
* 动态数组支持所有变量数据类型作为元素类型，包括数组。
* 动态数组中的越界访问会指向数据类型的默认值。

**动态数组函数一览表**

**序号** | **函数**         | **示例** | **描述**                                                                  | 
|---|----------------------------| -------------- | -------------------------------------------------------------------------------------|
1|构造函数： new [value] | abc.new[] | 设置动态数组的大小并初始化其元素或在运行时更改数组的大小。如果该值为零，则数组将变为空。如果该值为负数，则表示错误。   |       
2|函数： int size() | abc.size() | size() 方法返回动态数组的当前大小，如果数组尚未创建，则返回零 | 
3|函数： void delete() | abc.delete() | delete() 方法清空数组，导致数组大小为零 |

                                 Table.2. dynamic array methods
---



**动态数组的应用：**

可以在模拟期间分配和重新调整大小的动态数组将避免这种不必要的内存分配。

---

## 4.关联数组 Associative Arrays:

关联数组是一种非合并数组数据类型。它在使用之前不会分配任何存储空间，并且用于访问元素的索引类型不限于整数。

**语法:-** `<data_type> array_name [index_type]`

其中，索引类型是任何数据类型或其通配符“*”。

**示例,**

`int abc[*];`

`abc  = '{ 1:20, 25:22, 38:66};`

`string pqr[string];`

`pqr = '{"fruits":"mango" , "vegetables":"cucumber" , "season":"monsoon"};`

**一些注意事项：**

* 关联数组的元素都是非合并的。
* 模拟器可以将其存储为哈希（查找）表，以便极快地访问其元素。哈希表包含一组元素的数组。称为哈希函数的函数生成一个唯一键来计算该数组的索引，从中获得正确的数组元素值。
* 关联数组中的元素的访问方式与一维数组中的元素类似。
* 如果尝试读取无效（不存在）的关联数组条目，则模拟器将发出警告，并为 4 状态整数类型返回值“x”，或为 2-状态整数类型返回值“0”。状态积分类型。
* 使用“*”这个通配符会增加模拟时间，因此在声明数组时避免使用它。

**关联数组方法一览表：**

**Sr. No**| **Function** | **示例** | **Description**
|-- | -- | -- | --
1| int num () | abc.num() | Returns the number of entries in the associative array
2| int size () | abc.size() | Also returns the number of entries, if empty 0 is returned
3| void delete ([input index]) | abc.delete(index) | index when specified deletes the entry at that index, else the whole array is deleted
4| int exists (input index) | abc.exists(index) | Checks whether an element exists at specified index; returns 1 if it does, else 0
5| int first (ref index) | abc.first(index) | Assigns to the given index variable the value of the first index; returns 0 for empty array
6| int last (ref index) | abc.last(index) | Assigns to given index variable the value of the last index; returns 0 for empty array
7| int next (ref index) | abc.next(index) | Finds the smallest index whose value is greater than the given index
8| int prev (ref index) | abc.prev(index) | Finds the largest index whose value is smaller than the given index

                                  Table.3. associative arrays methods

The below figure shows the output of associative array.

![associative](https://user-images.githubusercontent.com/110448056/186892320-543d76d4-30e2-4f1b-adbc-dd9a68969c25.png)

                                 Figure.11 associative array output

**Github lab code link:-** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/associative_array/associative/associative_array.sv

**Github lab output link:-** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/associative_array/associative/associative_array.log

---

The below figure shows the output of associative array methods.
In example,

`int abc[string];`

`abc = '{"vadodara" : 10, "ahmedabad" : 25, "rajkot" : 55, "surendranagar" : 38, "surat":48};`

![associative_methods](https://user-images.githubusercontent.com/110448056/187507122-51b4629c-b817-4e74-9ce3-3d9f7b2ff9a2.png)

                                Figure.12 associative methods output

**Github lab code link:-** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/associative_array/associative_methods/associative_methods.sv

**Github lab output link:-** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/associative_array/associative_methods/associative_mthod.log

---

**Applications of associative arrays:**

Associative arrays used to design Content Addressable Memories (CAMs). Random read or write tests for verification of memories could use associative arrays for storing data only for addresses which have been written. This would take up significantly much lesser memory than the entire array normally used in Verilog.

---

# 5.Queue
Queue is a datatype used to have the variable size ordered collection of same datatypes in unpacked array format, it is used to insert the element in the array and delete the element in the array by both the ends. It is like buffer, used to model the first in first out(FIFO) and last in first out (LIFO).

****语法****: `data_type name[$];`
                 
data_type - data_type of queue element  
name - name of the queue  
[$] - declare the unbounded queue  

There are two types of queue declaration

## 1. bounded

 The queue as the size limit. we need to provide the max value while declare the queue 
 
语法: `data_type name[$:255];`
 
Here $- first element
255 - last element

![bounded queue](https://user-images.githubusercontent.com/110412474/186423427-f222976c-7179-40ac-83fb-0ae011222e72.jpg)

                            Figure.13 Bounded queue with push and pop operation
---

## 2. unbounded

 The queue as no size limit. we do not provide an size of queue it is a variable size queue.
 
语法: `data_type name[$];`
     
Here 0 - first element
$ - last element


![unbounded queue](https://user-images.githubusercontent.com/110412474/186423948-b22286aa-8de7-4dde-9b0e-08bbdf394306.jpg)

                            Figure.14 Unbounded queue with push and pop operation                         
---  

****Queue method cheat sheet****
Method | Example | Description  
-- | --  | --- 
function int size ();| queue1.size(); |  returns the number of items in the queue
function void insert (input integer index, input element_t item); | queue1.insert(int 0, 2); | inserts the given item at the specified index position
function void delete ( [input integer index] ); | queue1.delete(0); | deletes the item at the specified index position
function element_t push_front (input element_t item); | queue1.push_front("yelahanka"); | inserts the given element at the front of the queue
function element_t push_back (input element_t item); | queue1.push_back("udupi"); | inserts the given element at the end of the queue
function void pop_front (); | queue1.pop_front() | removes and returns the first element of the queue
function void pop_back (); | queue1.pop_back() | removes and returns the last element of the queue
  
                    Table.4 Queue Methods
---

## Queue Methods

Example.1 : consider the variable size queue named as queue1 = {2,7,1,9,9,7}, the output is shown in Fig.1
   
* ****size():****

Display the number of element in the queue ,if the queue is empty display the empty array.  
Expression: queue1.size()- It is used to display the size of the array queue1.   
output : 6  

* ****delete():****  
  
It is used to delete the queue element of specified index position.  
Expression : queue.delete(0) - It delete the array element '2' in the zeroth index position in the queue1.   
ouput: '{7, 1, 9, 9, 7} 

* ****insert(index, queue_element):****

  It is used to insert the queue element in the particular index position.  
  Expression: insert(0, 2)- It insert the array element '2' in the zeroth index position in the queue1.  
 output: '{ 2, 7, 1, 9, 9, 7}  

The below Figure.12 shows the output for size(), delete(), insert() Methods of Queue.
  
![newqueue1](https://user-images.githubusercontent.com/110412474/186829636-ba817def-7c37-4c16-9f50-af55f1bc9f84.JPG)


                          Figure.15 Queue Method Example.1
 
Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Queue/queue_method1/queue.sv

Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Queue/queue_method1/queue_data_type.log



---

The below Figure.12.1 show the output to delete the whole array element in the queue1.   
considering the variable size queue named as queue1 = {2,7,1,9,9,7}

![queue12](https://user-images.githubusercontent.com/110412474/187353273-93ea69e7-4923-4281-8096-539d30436525.JPG)

                                   Figure.16 Queue Method Example.1

**Github code lab link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Queue/queue_method3/queue.sv

**Github code output link:** https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Queue/queue_method3/makefile
 
-------

Example.2 : consider the variable size queue named as  
 queue1 ={"manipal", "bangalore", "udupi"};   

* ****pop.front():****
  
It remove the queue element from the front of the queue and return the first queue element.  
 In the above example, the array element from the front of the queue1 is removed i.e "manipal".        
 Now  After removing the array element the queue1 as the elements. queue1 ={ "bangalore", "udupi"};

* ****pop.back():****
  
It remove the queue element from the back of the queue and return the queue last queue element.  
  In the above example, the array element from the back of the queue1 is removed i.e "udupi".    
  Now After removing the array element the queue1 as the elements. queue1 = `{"bangalore"}
  
* ****push.front():****
  
It insert the queue element to the front of the queue.  
 Expression: push.front("yelahanka") - Insert the array element to the front of the queue1.  
  After push.front() the array elements of queue1 is '{"yelahanka", "bangalore"}  
  
* ****push.back():****
  
It insert the queue element to the back of the queue.  
  Expression: push.back("udupi")- Insert the array element to the back of the queue1  
  After push,back() the array elements of the queue1 is '{"yelahanka", "bangalore", "udupi"}

The below Figure.2 shows the output of pop.front(), pop.back(), push.front(), push.back(), Methods of Queue.
  
![newqueue2](https://user-images.githubusercontent.com/110412474/186828222-396f58a1-fdb4-4e89-88a6-506185f9495a.JPG)

                             Figure.17 Queue Method Example.2

 Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Queue/queue_method2/queue.sv

 Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Queue/queue_method2/queue_data.log
    
---

## Advantages and disadvantages of Arrays:

**Arrays Type** | **Advantage** | **Disadvantage**
-- | -- | --
Fixed Size Arrays | 1) Size can be calculated previously before run time. 2) Memory allocated in ROM in bss section of memory and simulation time less compared to unpacked arrays.  | 1)  Size is fixed we can’t expands the arrays.   2) Memory wastage.
Dynamic Arrays | 1) Continues memory allocation   2) We can jump from one memory location to another using loops.  3) We can travel in array at ease due to order   4) Time taken to execute is less compared to queues | 1) We can’t insert and delete the value at particular index location   2) Memories allocated in heap memory and so simulation time is more compared to fixed arrays
Associative Arrays | 1) It’s Memory friendly   2) Any data type is used for indexing  3) We can insert and delete the values at particular index | 1) Memories allocation is discontinuous    2) No fixed relation between indexing and so travelling through array is difficult 3) Id/keys required to jump to the other memory location in array
Queues | 1) We can insert and delete the values at particular index    2) We can insert elements in between existing elements   3) Large amount of data can manage efficiently with ease.  4) Push &   pop operation can be performed easily so better than associative arrays | 1) Time taken to execute is more compared to the dynamic arrays   2) It is bit complex as it expands / increases compared to dynamic arrays.


# 6.Array Manipulation Method
In the System Verilog the array Manipulation method are the built in method used to searching and ordering. The array manipulation method iterate through the each array element to evaluate the expression given by the with clause. The with clause is must for the some of the method and for some it is optional. "with" is refer to evaluate the existing array with the conditions.The below figure shows the Flow chart of Array Manipulation Method

![Array Manipulation Method](https://user-images.githubusercontent.com/110412474/186419438-45f9dc16-d26b-4846-a7a1-ba8c3da67a46.jpg)
 
                                        Figure.18 Flow chart of Array Manipulation Method
### Array Manipulation Method Cheat Sheet

****Note**** :Non-Destructive-The array whose output is stored in the another array it will not effect the original array)  

Method | Example | Description
-- | -- | -- 
find() with condition(); | array.find(check) with (check >="oldtown")  | Returns all elements satisfying the given expression
find_index() with condition(); | array.find_index(check) with (check =="yelahanka"); |  Returns the indices of all elements satisfying the given expression  
find_first() with condition(); |  array.find_first(check) with (check < "yelahanka" & check >= "newton" ); |  Returns the first element satisfying the given expression  
find_first_index() with condition();| array.find_first_index(check) with (check < "yelahanka"); | Returns the index of the first element satisfying the given expression
find_last() with condition(); | array.find_last(check) with (check < "oldtown");  | Returns the last element satisfying the given expression
find_last_index() with condition(); | array.find_last_index(check) with (check < "oldtown"); |  Returns the index of the last element satisfying the given expression
function max(); | array.max(); | Return the element which as maximum value
function min(); | array.min(); | Return the element which as minimum value
function unique(); | array.unique(); | Return the all elements which as unique value
function unique_index(); | array.unique_index(); | Return the all index place which as unique value
function sum(); | array.sum(); | return the sum of all the element
function product(); | array.product(); | return the product of all the element
function and(); | array.and(); | Return the bitwise AND(&) of all the element
function or(); | array.or(); | Return the bitwise OR of all the element in an array
function xor(); | array.xor(); | Return the bitwise XOR(^) of all the element in an array

         Table.6.1. Array Manipulation Method

### Array Manipulation Method Cheat Sheet

****Note****: Destructive-The array whose output is directly effected to the original array

Method | Example | Description
-- | -- | --
function reverse(); | array.reverse(); | Reverse the order of array element
function sort(); | array.sort(); | sort the array element in ascending order
function rsort(); | array.rsort(); | sort the array element in descending order
function shuffle(); | array.shuffle(); | shuffle the array element such that the value of index is in Randomized order

              Table.6.2. Array Manipulation Method
## Array locator Method
We declare the array with some elements by using the array locator method we can filter the values of the existing array by using the with clause evaluation conditions and all the element satisfyingly the condition are put in an array or return the value. The array locator method uses the with clause  for the below methods,

Example:  consider the array of five elements, shown the output in Fig.2.1:, 

array[5] = {"bangalore", "yelahanka", "maruthinagar", "oldtown", "newtown"};  

The ASCII value for b=098, y=121, m=109, o=111, n=110.  

Note: Here the comparison happens with the each ascii character of a string with the another string's of each ascii character sequentially. If the first ascii value of each character of a string is same, then it will compare the next ascii character of a string.  

* ****find():****  

This method is used to find the value in the existing array based on with clause conditional expressions.

Expression: result = array.find(check) with (check >="oldtown")  
It will find the string from the existing array based on the condition (check >="oldtown), here the ascii value of 'y' is greater than o ,so it will print the output '{"yelahanka", "oldtown"}.


* ****find_index():****  

It is used to write the indices of all the element which satisfy the condition or given expressions.

Expression :  a = array.find_index(check) with (check =="yelahanka");  
It will find the index position of the string "yelahanka" and print the output index position of string "yelahanka" as '{1}.

* ****find_first():****

Write the first element which satisfy the given expression or condition and does not check the condition for other element in the array it will return only the first element.

Expression : result = array.find_first(check) with (check < "yelahanka" & check >= "newton" );
It will find the string which will satisfy the condition, here the 'o' has great ascii value than n and lesser than y, so it will return the first string from the output array as '{"oldtown"}.   

* ****find_first_index():****  

Used to return the first index of an array based on the given condition. 

Expression: a = array.find_first_index(check) with (check < "yelahanka");  
It will find the index position of the string if the string match with the condition then it will print the index position of matched string it will not check for the other string character in the existing string it only print the first index position of an array, here 'b' as less ascii value compared to 'y', so the output is '{0}. 

* ****find_last():****

Return the last value of the array which satisfy the given expression the given expression is evaluate for whole existing array, then the resultant array last element is used to display.

Expression :  result = array.find_last(check) with (check < "oldtown");  
It will find all the array element which will match the condition, here 'b', 'm' and 'n' are having less ascii value compared to 'o', so it will print only the last array element as '{"newtown"} .

* ****find_last_index():****  

Return the last index of the array which satisfy the given expression the given expression is evaluate for whole existing array, then the resultant array last element index is used to display.

Expression:  a = array.find_last_index(check) with (check < "oldtown");  
It will find all the index position of the element which will match the condition, here 'b', 'm' and 'n' are having less ascii value compared to 'o', so it will print only the last array index position as '{4} . 
 
The below Figure 15 shows the output of Array locator methods of function find()

![newarrayfind](https://user-images.githubusercontent.com/110412474/186823831-8aa6de65-6db3-446e-8c13-b9b541aca0aa.JPG)
                                      
                                               Figure.19 Array Locator Method 
Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_find/array.sv

Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_find/arrayfind.log

------

# The Array Locator Method optional 'with' clause

****示例****: consider array of five elements, shown the output in Figure.16

array[8] = {1,9,9,7,2,7,0,6}

*  ****min()****:

Write the element with minimum value or based on the condition that is evaluated to minimum.  
In the above example, the minimum value is 0, so output: '{0}.

* **max()**:

Write the element with maximum value or based on the condition that is evaluated to maximum.  
In the above example, the maximum value is 9, so output: '{9}

* ****unique()****:

 It will return the unique value form the array, if the values are repeated it will return only once.  
So the output for above example is, '{0,1,2,6,7,9}.

* ****unique_index()****:

Return the array element index whose values are different based on the unique expression/condition return the index of each different/unique values  
Expression: unique_index(): Return all the indices which is having the unique value. output = '{6,0,4,7,3,1}  

The below Figure 2.2 shows the output  for display the minimum value, maximum value , unique value and unique indices function of Array Manipulation Method.   

![newmax2](https://user-images.githubusercontent.com/110412474/186824043-319638ce-3631-427c-89c4-1a27dd814504.JPG)
                                      
                                            Figure.20 Array Locator Method
Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_max/arraymax.sv

Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_max/arraymax.log

-----------

# Array Ordering method

The Array ordering method used to sort the array in reverse manner, sort the element in ascending and descending order.

Example: consider the array of eight element, shown the output in Fig.3:

array[8] : {2,7,1,9,9,7,0,6}

* ****Reverse():****

Return the Array element in the reverse order.  
 Output for above example is, '{6,0,7,9,9,1,7,2}.

* ****sort():****

Sort the array element in the ascending order.  
So Output = '{0,1,2,6,7,7,9,9}

*  ****rsort():****

Sort the array elements in the descending order reverse of sort() method.  
So Ouptut = '{9,9,7,7,6,2,1,0)

* ****shuffle():****

Shuffle the order of the array element such that the index position of the existing array does not match with the resultant array. we can use the loop to shuffle the location of the array element.  
Expression: shuffle() - shuffle the array element such that the indcies place value should be different for each shuffle
for loop is used to shuffle the array elements
 output: 1st shuffle:'{9,0,9,2,7,6,7,1}  
         2nd shuffle:'{2,7,7,1,9,9,6,0}  
         3rd shuffle:'{1,0,6,9,7,7.2.9} 

The below Figure.3 shows the output of Array Ordering Method.

![neworder3](https://user-images.githubusercontent.com/110412474/186827961-0f1a61c5-c71e-4e70-90ce-2ddaf9c95a7c.JPG)


                                           Figure.21 Array ordering method

Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_ordering/arrayorder.sv

Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_ordering/array_order.log

------------

# Array Reduction Method  

Example: consider array of four element, shown the output in Fig.4: 
array[4]: {2,7,0,6}  

* ****sum():****

Return the output by adding the all the element in the existing array.
Here 2+7+0+6 = 15  
So, output : 15  

* ****product()****:

Return the output by multiplying the all the element in the existing array.  
 So, output: 0

* ****and():****

Return the output by doing the bitwise AND (&) operation to the all array element.  

    Here   010    
           111    
           000    
     (&)   110    
    output:000

* ****or():****

Return the output by doing the bitwise OR(|) operation for all array element.  
    
     Here   010      
            111      
            000      
      (|)   110   
    ouptut: 111    

*  ****xor():****

Return the output by doing the bitwise XOR(^) operation for all array element  

       Here   010      
              111      
              000      
        (^)   110   
      ouptut: 011    

The below Figure.18 shows the output for Array Reduction Method.



![newreduction4](https://user-images.githubusercontent.com/110412474/186825000-4e4f6341-d933-47e1-8638-4fad88e1d0f5.JPG)
                                      
                                                     Figure.22 Array Reduction Method

Github lab code link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_Reduction/arrayreduction.sv

Github lab output link: https://github.com/muneeb-mbytes/SystemVerilog_Course/blob/production/data_type/sv_arrays/Array_methods/Array_Reduction/array_reduction.log
